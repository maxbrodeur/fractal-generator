<!DOCTYPE html>
<html>
<head>
    <title>Rust/WebAssembly Fractal Generator Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .fractal-display {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        select, button, input {
            padding: 8px 12px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #canvas {
            border: 1px solid #ddd;
            max-width: 100%;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 120px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Rust/WebAssembly Fractal Generator</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Fractal Type:</label>
                <select id="fractalType">
                    <optgroup label="Chaos Game">
                        <option value="sierpinski">Sierpinski Triangle</option>
                    </optgroup>
                    <optgroup label="IFS (Iterated Function Systems)">
                        <option value="dragon">Dragon Curve</option>
                        <option value="fern">Barnsley Fern</option>
                        <option value="mandelbrot_like">Mandelbrot-like</option>
                        <option value="spiral">Spiral</option>
                        <option value="christmas">Christmas Tree</option>
                        <option value="leaf">Maple Leaf</option>
                    </optgroup>
                    <optgroup label="Escape-time Fractals">
                        <option value="mandelbrot">Mandelbrot Set</option>
                        <option value="julia">Julia Set</option>
                        <option value="burning_ship">Burning Ship</option>
                    </optgroup>
                    <optgroup label="Random Chaos Finder">
                        <option value="random_chaos">Random Chaotic Map</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="control-group" id="juliaControls" style="display: none;">
                <label>Julia C:</label>
                <input type="number" id="juliaReal" value="-0.7" step="0.1"> + 
                <input type="number" id="juliaImag" value="0.27015" step="0.1">i
            </div>
            
            <div class="control-group" id="chaosControls" style="display: none;">
                <label>Map Order:</label>
                <select id="chaosOrder">
                    <option value="quadratic">Quadratic</option>
                    <option value="cubic">Cubic</option>
                </select>
                <br>
                <label>Plot Points:</label>
                <input type="number" id="chaosPlotPoints" value="100000" min="10000" max="1000000" step="10000">
                <br>
                <label>Test Points:</label>
                <input type="number" id="chaosTestPoints" value="100000" min="10000" max="1000000" step="10000">
            </div>
            
            <div class="control-group">
                <label>Iterations:</label>
                <input type="number" id="iterations" value="50000" min="1000" max="1000000" step="1000">
            </div>
            
            <div class="control-group">
                <label>Canvas Size:</label>
                <select id="canvasSize">
                    <option value="400">400x400</option>
                    <option value="600" selected>600x600</option>
                    <option value="800">800x800</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Color Scheme:</label>
                <select id="colorScheme">
                    <option value="0">Fire</option>
                    <option value="1">Jet</option>
                    <option value="2">Prism</option>
                    <option value="3">Turbo</option>
                    <option value="4">Color Wheel</option>
                    <option value="5">GNU Plot</option>
                    <option value="6">BMY</option>
                </select>
            </div>
            
            <button onclick="generateFractal()">Generate Fractal</button>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div class="fractal-display">
            <canvas id="canvas" width="600" height="600"></canvas>
            <div id="info">Click "Generate Fractal" to begin</div>
        </div>
    </div>

    <!-- Debug Helpers -->
    <script src="debug-helpers.js"></script>

    <script type="module">
        import init, { 
            FractalGenerator, 
            Rule, 
            ColorScheme, 
            FractalPresets 
        } from './fractal-wasm/pkg/fractal_wasm.js';

        let generator;
        let wasm;

        async function initWasm() {
            try {
                wasm = await init();
                
                // Make classes globally available for debug helpers
                window.FractalGenerator = FractalGenerator;
                window.Rule = Rule;
                window.ColorScheme = ColorScheme;
                window.FractalPresets = FractalPresets;
                
                generator = new FractalGenerator();
                showStatus("WebAssembly module loaded successfully!", false);
                console.log("✅ WASM initialized successfully");
                console.log("🔧 Debug tools available at window.debugFractal");
                
                // Run automatic verification
                if (window.debugFractal) {
                    setTimeout(() => {
                        console.log('🧪 Running automatic module verification...');
                        window.debugFractal.checkModuleStatus();
                    }, 1000);
                }
            } catch (error) {
                console.error("❌ WASM initialization failed:", error);
                showStatus("Failed to load WebAssembly module: " + error.message, true);
                
                // Enhanced error reporting
                if (window.debugFractal) {
                    window.debugFractal.logError('WASM_INIT_FAILURE', error.message);
                }
                
                console.log('💡 Troubleshooting tips:');
                console.log('  1. Ensure you\'re using http://localhost:8000 (not file://)');
                console.log('  2. Check that WebAssembly files are built: npm run build');
                console.log('  3. Use window.debugFractal.generateDebugReport() for detailed info');
            }
        }

        function showStatus(message, isError = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = isError ? 'status error' : 'status';
            status.style.display = 'block';
            
            if (!isError) {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        window.generateFractal = async function() {
            if (!generator) {
                showStatus("WebAssembly not loaded yet", true);
                return;
            }

            const fractalType = document.getElementById('fractalType').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            const canvasSize = parseInt(document.getElementById('canvasSize').value);
            const colorScheme = parseInt(document.getElementById('colorScheme').value);
            
            // Update canvas size
            const canvas = document.getElementById('canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            showStatus("Generating fractal...", false);
            
            try {
                const startTime = performance.now();
                let result;
                
                if (fractalType === 'sierpinski') {
                    // Sierpinski Triangle using chaos game
                    const vertices = FractalPresets.sierpinski_triangle();
                    const transforms = [
                        [0.5, 0], // compression ratio, rotation angle
                        [0.5, 0],
                        [0.5, 0]
                    ];
                    const rule = new Rule(0, 0, false); // No special rules
                    
                    const points = generator.chaos_game(vertices, 0.0, 0.0, iterations, transforms, rule);
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                } else if (fractalType === 'dragon') {
                    // Dragon Curve using IFS
                    const transforms = FractalPresets.dragon_curve();
                    const probabilities = FractalPresets.dragon_curve_probs();
                    
                    const points = generator.ifs_fractal(0.0, 0.0, iterations, transforms, probabilities, "borke");
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                } else if (fractalType === 'fern') {
                    // Barnsley Fern using IFS  
                    const transforms = FractalPresets.barnsley_fern();
                    const probabilities = FractalPresets.barnsley_fern_probs();
                    
                    const points = generator.ifs_fractal(0.0, 0.0, iterations, transforms, probabilities, "borke");
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                } else if (fractalType === 'mandelbrot_like') {
                    // Mandelbrot-like using IFS
                    const transforms = FractalPresets.mandelbrot_like();
                    const probabilities = FractalPresets.mandelbrot_like_probs();
                    
                    const points = generator.ifs_fractal(0.0, 0.0, iterations, transforms, probabilities, "regular");
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                } else if (fractalType === 'spiral') {
                    // Spiral using IFS
                    const transforms = FractalPresets.spiral();
                    const probabilities = FractalPresets.spiral_probs();
                    
                    const points = generator.ifs_fractal(0.0, 0.0, iterations, transforms, probabilities, "borke");
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                } else if (fractalType === 'christmas') {
                    // Christmas Tree using IFS
                    const transforms = FractalPresets.christmas_tree();
                    const probabilities = FractalPresets.christmas_tree_probs();
                    
                    const points = generator.ifs_fractal(0.0, 0.0, iterations, transforms, probabilities, "borke");
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                } else if (fractalType === 'leaf') {
                    // Maple Leaf using IFS
                    const transforms = FractalPresets.maple_leaf();
                    const probabilities = FractalPresets.maple_leaf_probs();
                    
                    const points = generator.ifs_fractal(0.0, 0.0, iterations, transforms, probabilities, "borke");
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                } else if (fractalType === 'mandelbrot') {
                    // Mandelbrot Set
                    const iterCounts = generator.mandelbrot_set(canvasSize, canvasSize, -2.5, 1.0, -1.25, 1.25, 100);
                    result = generator.iterations_to_rgba(iterCounts, canvasSize, canvasSize, 100, colorScheme);
                    
                } else if (fractalType === 'julia') {
                    // Julia Set
                    const juliaReal = parseFloat(document.getElementById('juliaReal').value);
                    const juliaImag = parseFloat(document.getElementById('juliaImag').value);
                    
                    const iterCounts = generator.julia_set(canvasSize, canvasSize, -2.0, 2.0, -2.0, 2.0, juliaReal, juliaImag, 100);
                    result = generator.iterations_to_rgba(iterCounts, canvasSize, canvasSize, 100, colorScheme);
                    
                } else if (fractalType === 'burning_ship') {
                    // Burning Ship
                    const iterCounts = generator.burning_ship(canvasSize, canvasSize, -2.5, 1.0, -2.0, 1.0, 100);
                    result = generator.iterations_to_rgba(iterCounts, canvasSize, canvasSize, 100, colorScheme);
                } else if (fractalType === 'random_chaos') {
                    // Random Chaos Finder
                    const chaosOrder = document.getElementById('chaosOrder').value;
                    const plotPoints = parseInt(document.getElementById('chaosPlotPoints').value);
                    const testPoints = parseInt(document.getElementById('chaosTestPoints').value);
                    const isCubic = chaosOrder === 'cubic';
                    
                    showStatus(`Searching for chaotic map (${chaosOrder})...`);
                    
                    const startTime = performance.now();
                    const points = generator.find_random_chaos(plotPoints, testPoints, isCubic);
                    const endTime = performance.now();
                    
                    // Convert points to RGBA for display
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    
                    const searchTime = ((endTime - startTime) / 1000).toFixed(2);
                    showStatus(`Found chaotic ${chaosOrder} map in ${searchTime}s with ${plotPoints} points`);
                }
                
                // Display on canvas
                const ctx = canvas.getContext('2d');
                const imageData = new ImageData(new Uint8ClampedArray(result), canvasSize, canvasSize);
                ctx.putImageData(imageData, 0, 0);
                
                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(2);
                
                const pointInfo = ['mandelbrot', 'julia', 'burning_ship'].includes(fractalType) 
                    ? `${canvasSize}x${canvasSize} pixels` 
                    : `${iterations.toLocaleString()} points`;
                
                document.getElementById('info').innerHTML = 
                    `Generated ${pointInfo} in ${duration}ms<br>` +
                    `Fractal: ${fractalType}<br>` +
                    `Performance: ${(['mandelbrot', 'julia', 'burning_ship'].includes(fractalType) 
                        ? (canvasSize * canvasSize / duration * 1000).toFixed(0) + ' pixels/sec'
                        : (iterations / duration * 1000).toFixed(0) + ' points/sec')}`;
                
                showStatus(`Fractal generated successfully in ${duration}ms`, false);
                
            } catch (error) {
                showStatus("Error generating fractal: " + error.message, true);
                console.error("Generation error:", error);
            }
        };

        // Initialize when page loads
        initWasm();
        
        // Update canvas size when selection changes
        document.getElementById('canvasSize').addEventListener('change', function() {
            const size = parseInt(this.value);
            const canvas = document.getElementById('canvas');
            canvas.width = size;
            canvas.height = size;
            
            // Clear canvas
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            document.getElementById('info').textContent = "Canvas resized. Click 'Generate Fractal' to render.";
        });
        
        // Show/hide specific controls based on fractal type
        document.getElementById('fractalType').addEventListener('change', function() {
            const juliaControls = document.getElementById('juliaControls');
            const chaosControls = document.getElementById('chaosControls');
            
            // Hide all special controls first
            juliaControls.style.display = 'none';
            chaosControls.style.display = 'none';
            
            // Show relevant controls
            if (this.value === 'julia') {
                juliaControls.style.display = 'block';
            } else if (this.value === 'random_chaos') {
                chaosControls.style.display = 'block';
            }
        });
    </script>
</body>
</html>