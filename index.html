<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Generator - Interactive WebAssembly</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            grid-template-rows: auto 1fr auto;
            grid-template-areas: 
                "sidebar header"
                "sidebar main"
                "sidebar status";
            height: 100vh;
            gap: 0;
        }
        
        .header {
            grid-area: header;
            background: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        
        .header h1 {
            color: #4a5568;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }
        
        .btn-secondary:hover {
            background: #cbd5e0;
        }
        
        .sidebar {
            grid-area: sidebar;
            background: white;
            padding: 1rem;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .control-section {
            margin-bottom: 1.5rem;
        }
        
        .control-section h3 {
            color: #2d3748;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        .control-group {
            margin-bottom: 1rem;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #4a5568;
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .control-group input,
        .control-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }
        
        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .control-group small {
            display: block;
            margin-top: 0.25rem;
            color: #718096;
            font-size: 0.75rem;
            line-height: 1.2;
        }
        
        .main-content {
            grid-area: main;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            overflow: hidden;
        }
        
        .canvas-container {
            position: relative;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
            cursor: crosshair;
        }
        
        #fractalCanvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255,255,255,0.9);
            z-index: 10;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-bar {
            grid-area: status;
            background: #2d3748;
            color: white;
            padding: 0.75rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }
        
        .status-left {
            display: flex;
            gap: 2rem;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .zoom-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .zoom-btn {
            background: #4a5568;
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.2s;
        }
        
        .zoom-btn:hover {
            background: #667eea;
        }
        
        .dynamic-controls {
            display: none;
        }
        
        .dynamic-controls.active {
            display: block;
        }
        
        .method-presets {
            margin-top: 1rem;
        }
        
        .method-controls {
            border-top: 1px solid #e2e8f0;
            padding-top: 1rem;
            margin-top: 1rem;
        }
        
        .julia-controls .input-group {
            justify-content: space-between;
        }
        
        .julia-controls input {
            width: 60px;
        }
        
        .ifs-transform {
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            background: #f7fafc;
        }
        
        .ifs-transform h4 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: #4a5568;
        }
        
        .ifs-params {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }
        
        .ifs-params input {
            width: 100%;
            padding: 0.25rem;
            font-size: 0.8rem;
            border: 1px solid #cbd5e0;
            border-radius: 3px;
        }
        
        .ifs-params label {
            font-size: 0.7rem;
            color: #718096;
            margin-bottom: 0.2rem;
        }
        
        .notification {
            position: fixed;
            top: 5rem;
            right: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            background: #48bb78;
        }
        
        .notification.error {
            background: #f56565;
        }
        
        .notification.info {
            background: #4299e1;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr auto;
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "status";
            }
            
            .sidebar {
                max-height: 300px;
                padding: 1rem;
            }
            
            .header {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .main-content {
                padding: 1rem;
            }
            
            .status-bar {
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
                align-items: flex-start;
            }
            
            .status-left {
                gap: 1rem;
            }
        }
        
        @media (max-width: 480px) {
            .header-actions {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>🌀 Fractal Generator</h1>
            <div class="header-actions">
                <button class="btn btn-secondary" id="downloadBtn" disabled>
                    📥 Download PNG
                </button>
            </div>
        </header>
        
        <aside class="sidebar">
            <div class="control-section">
                <h3>Generation Method</h3>
                <div class="control-group">
                    <select id="fractalMethod">
                        <option value="escape_time">Escape-Time Fractals</option>
                        <option value="chaos_game">Chaos Game</option>
                        <option value="ifs">Iterated Function Systems (IFS)</option>
                        <option value="random_chaos">Random Chaos Finder</option>
                    </select>
                </div>
                
                <!-- Escape-Time Fractal Presets -->
                <div id="escapeTimePresets" class="control-group method-presets">
                    <label>Fractal Type</label>
                    <select id="escapeTimeType">
                        <option value="mandelbrot">Mandelbrot Set</option>
                        <option value="julia">Julia Set</option>
                        <option value="burning_ship">Burning Ship</option>
                    </select>
                </div>
                
                <!-- Chaos Game Presets -->
                <div id="chaosGamePresets" class="control-group method-presets" style="display: none;">
                    <label>Chaos Game Pattern</label>
                    <select id="chaosGameType">
                        <option value="sierpinski">Sierpinski Triangle</option>
                        <option value="sierpinski_carpet">Sierpinski Carpet</option>
                        <option value="vicsek">Vicsek Square</option>
                        <option value="t_square">T-Square</option>
                        <option value="techs">Techs Pattern</option>
                        <option value="webs">Web Pattern</option>
                    </select>
                </div>
                
                <!-- IFS Presets -->
                <div id="ifsPresets" class="control-group method-presets" style="display: none;">
                    <label>IFS Pattern</label>
                    <select id="ifsType">
                        <option value="fern">Barnsley Fern</option>
                        <option value="dragon">Dragon Curve</option>
                        <option value="leaf">Maple Leaf</option>
                        <option value="christmas">Christmas Tree</option>
                        <option value="spiral">Spiral</option>
                        <option value="mandelbrot_like">Mandelbrot-like IFS</option>
                        <option value="sierpinski_ifs">Sierpinski Triangle (IFS)</option>
                    </select>
                </div>
                
                <!-- Random Chaos Methods -->
                <div id="chaosFinderMethods" class="control-group method-presets" style="display: none;">
                    <label>Map Type</label>
                    <select id="chaosFinderType">
                        <option value="quadratic">Quadratic Map</option>
                        <option value="cubic">Cubic Map</option>
                    </select>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Parameters</h3>
                
                <!-- Universal Parameters -->
                <div class="control-group">
                    <label>Iterations</label>
                    <input type="number" id="iterations" value="50000" min="1000" max="1000000" step="1000">
                    <small id="iterationsHelp">Number of iterations or points to generate</small>
                </div>
                
                <div class="control-group">
                    <label>Canvas Size</label>
                    <select id="canvasSize">
                        <option value="400">400x400</option>
                        <option value="600" selected>600x600</option>
                        <option value="800">800x800</option>
                        <option value="1024">1024x1024</option>
                    </select>
                </div>
                
                <!-- Escape-Time Fractal Controls -->
                <div id="escapeTimeControls" class="method-controls">
                    <!-- Julia Set Controls -->
                    <div id="juliaControls" class="dynamic-controls julia-controls">
                        <div class="control-group">
                            <label>Complex Parameter</label>
                            <div class="input-group">
                                <input type="number" id="juliaReal" value="-0.7" step="0.01">
                                <span>+</span>
                                <input type="number" id="juliaImag" value="0.27015" step="0.01">
                                <span>i</span>
                            </div>
                            <small>Real and imaginary components of Julia set parameter</small>
                        </div>
                    </div>
                </div>
                
                <!-- Chaos Game Controls -->
                <div id="chaosGameControls" class="method-controls" style="display: none;">
                    <div class="control-group">
                        <label>Compression Ratio</label>
                        <input type="number" id="compressionRatio" value="0.5" min="0.1" max="1.0" step="0.05">
                        <small>Fraction of distance to jump toward vertex (0.1-1.0)</small>
                    </div>
                    <div class="control-group">
                        <label>Rotation Angle</label>
                        <input type="number" id="rotationAngle" value="0" min="-3.14" max="3.14" step="0.1">
                        <small>Rotation angle in radians</small>
                    </div>
                    <div class="control-group">
                        <label>Rule Length</label>
                        <input type="number" id="ruleLength" value="0" min="0" max="10" step="1">
                        <small>Number of previous vertex choices to track</small>
                    </div>
                    <div class="control-group">
                        <label>Rule Offset</label>
                        <input type="number" id="ruleOffset" value="0" min="-5" max="5" step="1">
                        <small>Forbidden offset from last vertex</small>
                    </div>
                    <div class="control-group">
                        <label>Rule Symmetry</label>
                        <select id="ruleSymmetry">
                            <option value="false">No</option>
                            <option value="true">Yes</option>
                        </select>
                        <small>Apply symmetric vertex selection restrictions</small>
                    </div>
                    <div class="control-group" id="techsSkewGroup" style="display: none;">
                        <label>Techs Skew</label>
                        <input type="number" id="techsSkew" value="0" min="-3" max="3" step="1">
                        <small>Variable offset parameter for Techs pattern</small>
                    </div>
                </div>
                
                <!-- IFS Controls -->
                <div id="ifsControls" class="method-controls" style="display: none;">
                    <div class="control-group">
                        <label>Starting Point X</label>
                        <input type="number" id="ifsStartX" value="0" step="0.1">
                        <small>Initial X coordinate for IFS iteration</small>
                    </div>
                    <div class="control-group">
                        <label>Starting Point Y</label>
                        <input type="number" id="ifsStartY" value="0" step="0.1">
                        <small>Initial Y coordinate for IFS iteration</small>
                    </div>
                    <div class="control-group">
                        <label>Parsing Mode</label>
                        <select id="ifsParseMode">
                            <option value="borke">Borke (a*x + b*y + e, c*x + d*y + f)</option>
                            <option value="regular">Regular (a*x + b*y + c, d*x + e*y + f)</option>
                        </select>
                        <small>How to interpret transformation parameters</small>
                    </div>
                    <div class="control-group">
                        <label>Number of Transformations</label>
                        <select id="ifsTransformCount">
                            <option value="2">2 Transformations</option>
                            <option value="3">3 Transformations</option>
                            <option value="4" selected>4 Transformations</option>
                        </select>
                        <small>How many affine transformations to use</small>
                    </div>
                    
                    <!-- Transformation parameters -->
                    <div id="ifsTransformations">
                        <!-- Will be populated dynamically -->
                    </div>
                    
                    <div class="control-group">
                        <label>Probabilities</label>
                        <input type="text" id="ifsProbabilities" value="0.01, 0.07, 0.07, 0.85" placeholder="e.g., 0.25, 0.25, 0.25, 0.25">
                        <small>Comma-separated probability weights (must sum to ~1.0)</small>
                    </div>
                </div>
                
                <!-- Random Chaos Finder Controls -->
                <div id="chaosFinderControls" class="method-controls" style="display: none;">
                    <div class="control-group">
                        <label>Plot Points</label>
                        <input type="number" id="chaosPlotPoints" value="100000" min="10000" max="1000000" step="10000">
                        <small>Number of points to plot for discovered map</small>
                    </div>
                    <div class="control-group">
                        <label>Test Points</label>
                        <input type="number" id="chaosTestPoints" value="100000" min="10000" max="1000000" step="10000">
                        <small>Number of points for Lyapunov exponent calculation</small>
                    </div>
                    <div class="control-group">
                        <label>Search Attempts</label>
                        <input type="number" id="searchAttempts" value="1000" min="100" max="10000" step="100">
                        <small>Maximum attempts to find chaotic map</small>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Visual</h3>
                <div class="control-group">
                    <label>Color Scheme</label>
                    <select id="colorScheme">
                        <option value="0">Fire</option>
                        <option value="1">Jet</option>
                        <option value="2">Prism</option>
                        <option value="3" selected>Turbo</option>
                        <option value="4">Color Wheel</option>
                        <option value="5">GNU Plot</option>
                        <option value="6">BMY</option>
                    </select>
                </div>
            </div>
            
            <!-- Generate Button -->
            <div class="control-section">
                <button class="btn" id="generateBtn" style="width: 100%; padding: 0.75rem; font-size: 1rem;">
                    ✨ Generate Fractal
                </button>
            </div>
        </aside>
        
        <main class="main-content">
            <div class="canvas-container" id="canvasContainer">
                <canvas id="fractalCanvas" width="600" height="600"></canvas>
                <div class="canvas-overlay" id="canvasOverlay">
                    <div>
                        <div class="loading-spinner"></div>
                        <p style="margin-top: 1rem;">Initializing WebAssembly...</p>
                    </div>
                </div>
            </div>
        </main>
        
        <footer class="status-bar">
            <div class="status-left">
                <div class="status-item">
                    <span>🎯</span>
                    <span id="positionStatus">Center: (0, 0)</span>
                </div>
                <div class="status-item">
                    <span>🔍</span>
                    <span id="zoomStatus">Zoom: 1.0x</span>
                </div>
                <div class="status-item">
                    <span>⏱️</span>
                    <span id="timeStatus">Ready</span>
                </div>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomInBtn" title="Zoom In">+</button>
                <button class="zoom-btn" id="zoomOutBtn" title="Zoom Out">-</button>
                <button class="zoom-btn" id="resetViewBtn" title="Reset View">⌂</button>
            </div>
        </footer>
    </div>

    <script>
        // Application State
        let generator = null;
        let isLoading = false;
        let currentFractal = null;
        
        // View State for zooming/panning
        let viewState = {
            centerX: 0,
            centerY: 0,
            zoom: 1.0,
            fractalType: 'mandelbrot'
        };

        // DOM Elements
        const elements = {
            canvas: document.getElementById('fractalCanvas'),
            overlay: document.getElementById('canvasOverlay'),
            container: document.getElementById('canvasContainer'),
            generateBtn: document.getElementById('generateBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            
            // Method and preset selectors
            fractalMethod: document.getElementById('fractalMethod'),
            escapeTimePresets: document.getElementById('escapeTimePresets'),
            chaosGamePresets: document.getElementById('chaosGamePresets'),
            ifsPresets: document.getElementById('ifsPresets'),
            chaosFinderMethods: document.getElementById('chaosFinderMethods'),
            escapeTimeType: document.getElementById('escapeTimeType'),
            chaosGameType: document.getElementById('chaosGameType'),
            ifsType: document.getElementById('ifsType'),
            chaosFinderType: document.getElementById('chaosFinderType'),
            
            // Universal parameters
            iterations: document.getElementById('iterations'),
            canvasSize: document.getElementById('canvasSize'),
            colorScheme: document.getElementById('colorScheme'),
            iterationsHelp: document.getElementById('iterationsHelp'),
            
            // Method-specific control sections
            escapeTimeControls: document.getElementById('escapeTimeControls'),
            chaosGameControls: document.getElementById('chaosGameControls'),
            ifsControls: document.getElementById('ifsControls'),
            chaosFinderControls: document.getElementById('chaosFinderControls'),
            
            // Escape-time fractal controls
            juliaControls: document.getElementById('juliaControls'),
            juliaReal: document.getElementById('juliaReal'),
            juliaImag: document.getElementById('juliaImag'),
            
            // Chaos game controls
            compressionRatio: document.getElementById('compressionRatio'),
            rotationAngle: document.getElementById('rotationAngle'),
            ruleLength: document.getElementById('ruleLength'),
            ruleOffset: document.getElementById('ruleOffset'),
            ruleSymmetry: document.getElementById('ruleSymmetry'),
            techsSkew: document.getElementById('techsSkew'),
            techsSkewGroup: document.getElementById('techsSkewGroup'),
            
            // IFS controls
            ifsStartX: document.getElementById('ifsStartX'),
            ifsStartY: document.getElementById('ifsStartY'),
            ifsParseMode: document.getElementById('ifsParseMode'),
            ifsTransformCount: document.getElementById('ifsTransformCount'),
            ifsTransformations: document.getElementById('ifsTransformations'),
            ifsProbabilities: document.getElementById('ifsProbabilities'),
            
            // Chaos finder controls
            chaosPlotPoints: document.getElementById('chaosPlotPoints'),
            chaosTestPoints: document.getElementById('chaosTestPoints'),
            searchAttempts: document.getElementById('searchAttempts'),
            
            // Status and zoom controls
            positionStatus: document.getElementById('positionStatus'),
            zoomStatus: document.getElementById('zoomStatus'),
            timeStatus: document.getElementById('timeStatus'),
            zoomInBtn: document.getElementById('zoomInBtn'),
            zoomOutBtn: document.getElementById('zoomOutBtn'),
            resetViewBtn: document.getElementById('resetViewBtn')
        };

        // Initialize WebAssembly (attempt to load, handle gracefully if not available)
        async function initWasm() {
            try {
                const wasmModule = await import('./fractal-wasm/pkg/fractal_wasm.js');
                await wasmModule.default();
                const { FractalGenerator, Rule, ColorScheme, FractalPresets } = wasmModule;
                
                // Store globally for use in other functions
                window.FractalGenerator = FractalGenerator;
                window.Rule = Rule;
                window.ColorScheme = ColorScheme;
                window.FractalPresets = FractalPresets;
                
                generator = new FractalGenerator();
                hideOverlay();
                showNotification('WebAssembly loaded successfully!', 'success');
                updateStatus();
                console.log('WASM initialized successfully');
            } catch (error) {
                hideOverlay();
                showNotification(`WebAssembly not available (${error.message}). UI demo mode.`, 'info');
                console.log('WASM initialization failed, running in UI demo mode:', error);
            }
        }

        // UI Helper Functions
        function showOverlay(message = 'Generating fractal...') {
            elements.overlay.innerHTML = `
                <div>
                    <div class="loading-spinner"></div>
                    <p style="margin-top: 1rem;">${message}</p>
                </div>
            `;
            elements.overlay.style.display = 'flex';
        }

        function hideOverlay() {
            elements.overlay.style.display = 'none';
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function updateStatus() {
            elements.positionStatus.textContent = `Center: (${viewState.centerX.toFixed(3)}, ${viewState.centerY.toFixed(3)})`;
            elements.zoomStatus.textContent = `Zoom: ${viewState.zoom.toFixed(1)}x`;
        }

        function setLoading(loading) {
            isLoading = loading;
            elements.generateBtn.disabled = loading;
            elements.downloadBtn.disabled = loading || !currentFractal;
            
            if (loading) {
                elements.generateBtn.textContent = '⏳ Generating...';
            } else {
                elements.generateBtn.textContent = '✨ Generate';
            }
        }

        // Fractal Generation
        async function generateFractal() {
            if (isLoading) return;
            
            if (!generator) {
                showNotification('WebAssembly not loaded. Please check setup instructions.', 'error');
                return;
            }

            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            const iterations = parseInt(elements.iterations.value);
            const canvasSize = parseInt(elements.canvasSize.value);
            const colorScheme = parseInt(elements.colorScheme.value);

            // Update canvas size
            elements.canvas.width = canvasSize;
            elements.canvas.height = canvasSize;

            setLoading(true);
            showOverlay();

            try {
                const startTime = performance.now();
                let result;
                
                // Get WASM classes from global scope
                const { Rule, FractalPresets } = window;
                
                if (method === 'escape_time') {
                    // Escape-time fractals (Mandelbrot, Julia, Burning Ship)
                    if (fractalType === 'mandelbrot') {
                        const bounds = getMandelbrotBounds(canvasSize);
                        const iterCounts = generator.mandelbrot_set(
                            canvasSize, canvasSize, 
                            bounds.xMin, bounds.xMax, 
                            bounds.yMin, bounds.yMax, 
                            iterations
                        );
                        result = generator.iterations_to_rgba(iterCounts, canvasSize, canvasSize, iterations, colorScheme);
                        
                    } else if (fractalType === 'julia') {
                        const bounds = getJuliaBounds(canvasSize);
                        const real = parseFloat(elements.juliaReal.value);
                        const imag = parseFloat(elements.juliaImag.value);
                        const iterCounts = generator.julia_set(
                            canvasSize, canvasSize,
                            bounds.xMin, bounds.xMax,
                            bounds.yMin, bounds.yMax,
                            real, imag, iterations
                        );
                        result = generator.iterations_to_rgba(iterCounts, canvasSize, canvasSize, iterations, colorScheme);
                        
                    } else if (fractalType === 'burning_ship') {
                        const bounds = getBurningShipBounds(canvasSize);
                        const iterCounts = generator.burning_ship(
                            canvasSize, canvasSize,
                            bounds.xMin, bounds.xMax,
                            bounds.yMin, bounds.yMax,
                            iterations
                        );
                        result = generator.iterations_to_rgba(iterCounts, canvasSize, canvasSize, iterations, colorScheme);
                    }
                    
                } else if (method === 'chaos_game') {
                    // Chaos game fractals
                    const compressionRatio = parseFloat(elements.compressionRatio.value);
                    const rotationAngle = parseFloat(elements.rotationAngle.value);
                    const ruleLength = parseInt(elements.ruleLength.value);
                    let ruleOffset = parseInt(elements.ruleOffset.value);
                    const ruleSymmetry = elements.ruleSymmetry.value === 'true';
                    
                    // For techs pattern, use techs skew as offset
                    if (fractalType === 'techs') {
                        ruleOffset = parseInt(elements.techsSkew.value);
                    }
                    
                    const transforms = [[compressionRatio, rotationAngle]];
                    const rule = new Rule(ruleLength, ruleOffset, ruleSymmetry);
                    
                    if (fractalType === 'sierpinski') {
                        const vertices = FractalPresets.sierpinski_triangle();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, iterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                        
                    } else if (fractalType === 'sierpinski_carpet') {
                        const vertices = FractalPresets.sierpinski_carpet();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, iterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                        
                    } else if (fractalType === 'vicsek') {
                        const vertices = FractalPresets.vicsek_square();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, iterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                        
                    } else if (fractalType === 't_square') {
                        const vertices = FractalPresets.t_square();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, iterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                        
                    } else if (fractalType === 'techs') {
                        const vertices = FractalPresets.techs_pattern();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, iterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                        
                    } else if (fractalType === 'webs') {
                        const vertices = FractalPresets.web_pattern();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, iterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    }
                    
                } else if (method === 'ifs') {
                    // IFS fractals using user-defined parameters
                    const startX = parseFloat(elements.ifsStartX.value);
                    const startY = parseFloat(elements.ifsStartY.value);
                    
                    try {
                        const { transforms, probabilities, parseMode } = getIFSParameters();
                        const points = generator.ifs_fractal(startX, startY, iterations, transforms, probabilities, parseMode);
                        result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                    } catch (error) {
                        showNotification(`IFS Error: ${error.message}`, 'error');
                        setLoading(false);
                        return;
                    }
                    
                } else if (method === 'random_chaos') {
                    // Random chaos finder
                    const chaosType = elements.chaosFinderType.value;
                    const plotPoints = parseInt(elements.chaosPlotPoints.value);
                    const testPoints = parseInt(elements.chaosTestPoints.value);
                    const isCubic = chaosType === 'cubic';
                    
                    showOverlay(`Searching for chaotic ${chaosType} map...`);
                    const points = generator.find_random_chaos(plotPoints, testPoints, isCubic);
                    result = generator.points_to_rgba(points, canvasSize, canvasSize, colorScheme);
                }

                // Display result
                const ctx = elements.canvas.getContext('2d');
                const imageData = new ImageData(new Uint8ClampedArray(result), canvasSize, canvasSize);
                ctx.putImageData(imageData, 0, 0);

                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(2);
                
                // Update status
                const pointInfo = method === 'escape_time'
                    ? `${canvasSize}x${canvasSize} pixels` 
                    : `${iterations.toLocaleString()} points`;
                    
                elements.timeStatus.textContent = `Rendered in ${duration}ms`;
                
                showNotification(`Fractal generated successfully! (${pointInfo} in ${duration}ms)`, 'success');
                
                currentFractal = {
                    type: fractalType,
                    method: method,
                    imageData: result,
                    size: canvasSize
                };
                
                viewState.fractalType = fractalType;

            } catch (error) {
                showNotification(`Error generating fractal: ${error.message}`, 'error');
                console.error('Generation error:', error);
            } finally {
                setLoading(false);
                hideOverlay();
            }
        }

        // Get bounds for different fractal types based on zoom and pan
        function getMandelbrotBounds(size) {
            const baseWidth = 3.5;
            const baseHeight = 2.5;
            const width = baseWidth / viewState.zoom;
            const height = baseHeight / viewState.zoom;
            
            return {
                xMin: viewState.centerX - width / 2,
                xMax: viewState.centerX + width / 2,
                yMin: viewState.centerY - height / 2,
                yMax: viewState.centerY + height / 2
            };
        }

        function getJuliaBounds(size) {
            const baseWidth = 4.0;
            const baseHeight = 4.0;
            const width = baseWidth / viewState.zoom;
            const height = baseHeight / viewState.zoom;
            
            return {
                xMin: viewState.centerX - width / 2,
                xMax: viewState.centerX + width / 2,
                yMin: viewState.centerY - height / 2,
                yMax: viewState.centerY + height / 2
            };
        }

        function getBurningShipBounds(size) {
            const baseWidth = 3.5;
            const baseHeight = 3.0;
            const width = baseWidth / viewState.zoom;
            const height = baseHeight / viewState.zoom;
            
            return {
                xMin: viewState.centerX - width / 2,
                xMax: viewState.centerX + width / 2,
                yMin: viewState.centerY - height / 2,
                yMax: viewState.centerY + height / 2
            };
        }

        // Canvas Interaction
        function getCanvasCoordinates(clientX, clientY) {
            const rect = elements.canvas.getBoundingClientRect();
            const x = (clientX - rect.left) / rect.width;
            const y = (clientY - rect.top) / rect.height;
            return { x, y };
        }

        function canvasToFractalCoordinates(x, y) {
            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            
            // Only escape-time fractals support coordinate-based interaction
            if (method !== 'escape_time') {
                return { x: 0, y: 0 }; // Non-coordinate fractals
            }
            
            let bounds;
            
            if (fractalType === 'mandelbrot') {
                bounds = getMandelbrotBounds(elements.canvas.width);
            } else if (fractalType === 'julia') {
                bounds = getJuliaBounds(elements.canvas.width);
            } else if (fractalType === 'burning_ship') {
                bounds = getBurningShipBounds(elements.canvas.width);
            } else {
                return { x: 0, y: 0 };
            }
            
            const fractalX = bounds.xMin + x * (bounds.xMax - bounds.xMin);
            const fractalY = bounds.yMin + y * (bounds.yMax - bounds.yMin);
            
            return { x: fractalX, y: fractalY };
        }

        // Zoom functionality
        function zoomIn(centerX = null, centerY = null) {
            if (centerX !== null && centerY !== null) {
                const coords = canvasToFractalCoordinates(centerX, centerY);
                viewState.centerX = coords.x;
                viewState.centerY = coords.y;
            }
            viewState.zoom *= 2.0;
            updateStatus();
            generateFractal();
        }

        function zoomOut() {
            viewState.zoom /= 2.0;
            updateStatus();
            generateFractal();
        }

        function resetView() {
            viewState.centerX = 0;
            viewState.centerY = 0;
            viewState.zoom = 1.0;
            updateStatus();
            generateFractal();
        }

        // Download functionality
        function downloadPNG() {
            if (!currentFractal) return;
            
            const link = document.createElement('a');
            link.download = `fractal-${currentFractal.type}-${Date.now()}.png`;
            link.href = elements.canvas.toDataURL('image/png');
            link.click();
            
            showNotification('Fractal image downloaded!', 'success');
        }

        // Dynamic control visibility
        function updateControlVisibility() {
            const method = elements.fractalMethod.value;
            
            // Hide all preset selectors
            elements.escapeTimePresets.style.display = 'none';
            elements.chaosGamePresets.style.display = 'none';
            elements.ifsPresets.style.display = 'none';
            elements.chaosFinderMethods.style.display = 'none';
            
            // Hide all method control sections
            elements.escapeTimeControls.style.display = 'none';
            elements.chaosGameControls.style.display = 'none';
            elements.ifsControls.style.display = 'none';
            elements.chaosFinderControls.style.display = 'none';
            
            // Show relevant preset selector and controls
            if (method === 'escape_time') {
                elements.escapeTimePresets.style.display = 'block';
                elements.escapeTimeControls.style.display = 'block';
                elements.iterationsHelp.textContent = 'Maximum iterations for escape-time calculation';
                updateEscapeTimeControls();
                
            } else if (method === 'chaos_game') {
                elements.chaosGamePresets.style.display = 'block';
                elements.chaosGameControls.style.display = 'block';
                elements.iterationsHelp.textContent = 'Number of points to generate with chaos game';
                updateChaosGameDefaults();
                
            } else if (method === 'ifs') {
                elements.ifsPresets.style.display = 'block';
                elements.ifsControls.style.display = 'block';
                elements.iterationsHelp.textContent = 'Number of points to generate with IFS';
                
                // Initialize transformation inputs and load default preset
                createTransformationInputs();
                loadIFSPreset();
                
            } else if (method === 'random_chaos') {
                elements.chaosFinderMethods.style.display = 'block';
                elements.chaosFinderControls.style.display = 'block';
                elements.iterationsHelp.textContent = 'Points generated after finding chaotic map';
            }
        }
        
        function updateEscapeTimeControls() {
            const fractalType = elements.escapeTimeType.value;
            
            // Hide all escape-time specific controls
            elements.juliaControls.classList.remove('active');
            
            // Show relevant controls
            if (fractalType === 'julia') {
                elements.juliaControls.classList.add('active');
            }
        }
        
        function getCurrentFractalType() {
            const method = elements.fractalMethod.value;
            
            if (method === 'escape_time') {
                return elements.escapeTimeType.value;
            } else if (method === 'chaos_game') {
                return elements.chaosGameType.value;
            } else if (method === 'ifs') {
                const ifsType = elements.ifsType.value;
                // Map IFS types to internal names
                if (ifsType === 'sierpinski_ifs') return 'sierpinski_ifs';
                return ifsType;
            } else if (method === 'random_chaos') {
                return 'random_chaos';
            }
            
            return 'mandelbrot'; // fallback
        }

        function updateChaosGameDefaults() {
            const chaosType = elements.chaosGameType.value;
            
            // Hide techs-specific controls
            elements.techsSkewGroup.style.display = 'none';
            
            // Set appropriate defaults for different chaos game patterns
            if (chaosType === 'sierpinski') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 0;
                elements.ruleOffset.value = 0;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 'sierpinski_carpet') {
                elements.compressionRatio.value = 0.67; // 2/3
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 0;
                elements.ruleOffset.value = 0;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 'vicsek') {
                elements.compressionRatio.value = 0.67; // 2/3
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 0;
                elements.ruleOffset.value = 0;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 't_square') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 1;
                elements.ruleOffset.value = 2;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 'techs') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 1;
                elements.ruleOffset.value = 0; // Will be overridden by techsSkew
                elements.ruleSymmetry.value = 'false';
                elements.techsSkewGroup.style.display = 'block';
                
            } else if (chaosType === 'webs') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0.1;
                elements.ruleLength.value = 2;
                elements.ruleOffset.value = -1;
                elements.ruleSymmetry.value = 'true';
            }
        }

        // IFS parameter management functions
        function createTransformationInputs() {
            const count = parseInt(elements.ifsTransformCount.value);
            const container = elements.ifsTransformations;
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const transformDiv = document.createElement('div');
                transformDiv.className = 'ifs-transform';
                transformDiv.innerHTML = `
                    <h4>Transformation ${i + 1}</h4>
                    <div class="ifs-params">
                        <div>
                            <label>a</label>
                            <input type="number" id="ifs_a_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>b</label>
                            <input type="number" id="ifs_b_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>c</label>
                            <input type="number" id="ifs_c_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>d</label>
                            <input type="number" id="ifs_d_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>e</label>
                            <input type="number" id="ifs_e_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>f</label>
                            <input type="number" id="ifs_f_${i}" value="0" step="0.01">
                        </div>
                    </div>
                `;
                container.appendChild(transformDiv);
            }
            
            // Update probabilities placeholder
            const probPlaceholder = Array(count).fill(1.0 / count).map(p => p.toFixed(2)).join(', ');
            elements.ifsProbabilities.placeholder = `e.g., ${probPlaceholder}`;
        }

        function loadIFSPreset() {
            const presetName = elements.ifsType.value;
            
            // Preset data based on documentation
            const presets = {
                'dragon': {
                    transforms: [
                        [0.824074, 0.281428, -0.212346, 0.864198, -1.882290, -0.110607],
                        [0.088272, 0.520988, -0.463889, -0.377778, 0.785360, 8.095795]
                    ],
                    probabilities: [0.8, 0.2],
                    parseMode: 'borke'
                },
                'fern': {
                    transforms: [
                        [0.0, 0.0, 0.0, 0.16, 0.0, 0.0],
                        [0.2, -0.26, 0.23, 0.22, 0.0, 1.6],
                        [-0.15, 0.28, 0.26, 0.24, 0.0, 0.44],
                        [0.85, 0.04, -0.04, 0.85, 0.0, 1.6]
                    ],
                    probabilities: [0.01, 0.07, 0.07, 0.85],
                    parseMode: 'borke'
                },
                'leaf': {
                    transforms: [
                        [0.14, 0.01, 0.0, 0.51, -0.08, -1.31],
                        [0.43, 0.52, -0.45, 0.5, 1.49, -0.75],
                        [0.45, -0.49, 0.47, 0.47, -1.62, -0.74],
                        [0.49, 0.0, 0.0, 0.51, 0.02, 1.62]
                    ],
                    probabilities: [0.25, 0.25, 0.25, 0.25],
                    parseMode: 'borke'
                },
                'christmas': {
                    transforms: [
                        [0.0, -0.5, 0.5, 0.0, 0.5, 0.0],
                        [0.0, 0.5, -0.5, 0.0, 0.5, 0.5],
                        [0.5, 0.0, 0.0, 0.5, 0.25, 0.5]
                    ],
                    probabilities: [0.33, 0.33, 0.34],
                    parseMode: 'borke'
                },
                'spiral': {
                    transforms: [
                        [0.787879, -0.424242, 0.242424, 0.859848, 1.758647, 1.408065],
                        [-0.121212, 0.257576, 0.151515, 0.053030, -6.721654, 1.377236],
                        [0.181818, -0.136364, 0.090909, 0.181818, 6.086107, 1.568035]
                    ],
                    probabilities: [0.9, 0.05, 0.05],
                    parseMode: 'borke'
                },
                'mandelbrot_like': {
                    transforms: [
                        [0.2020, -0.8050, -0.3730, -0.6890, -0.3420, -0.6530],
                        [0.1380, 0.6650, 0.6600, -0.5020, -0.2220, -0.2770]
                    ],
                    probabilities: [0.5, 0.5],
                    parseMode: 'regular'
                },
                'sierpinski_ifs': {
                    transforms: [
                        [0.5, 0.0, 0.0, 0.0, 0.5, 0.0],
                        [0.5, 0.0, 0.5, 0.0, 0.5, 0.0],
                        [0.5, 0.0, 0.0, 0.0, 0.5, 0.5]
                    ],
                    probabilities: [0.33, 0.33, 0.34],
                    parseMode: 'regular'
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            // Set transform count and parsing mode
            elements.ifsTransformCount.value = preset.transforms.length;
            elements.ifsParseMode.value = preset.parseMode;
            
            // Create transform inputs with the correct count
            createTransformationInputs();
            
            // Fill in the transformation parameters
            preset.transforms.forEach((transform, i) => {
                document.getElementById(`ifs_a_${i}`).value = transform[0];
                document.getElementById(`ifs_b_${i}`).value = transform[1];
                document.getElementById(`ifs_c_${i}`).value = transform[2];
                document.getElementById(`ifs_d_${i}`).value = transform[3];
                document.getElementById(`ifs_e_${i}`).value = transform[4];
                document.getElementById(`ifs_f_${i}`).value = transform[5];
            });
            
            // Set probabilities
            elements.ifsProbabilities.value = preset.probabilities.join(', ');
        }

        function getIFSParameters() {
            const count = parseInt(elements.ifsTransformCount.value);
            const transforms = [];
            
            for (let i = 0; i < count; i++) {
                const transform = [
                    parseFloat(document.getElementById(`ifs_a_${i}`).value),
                    parseFloat(document.getElementById(`ifs_b_${i}`).value),
                    parseFloat(document.getElementById(`ifs_c_${i}`).value),
                    parseFloat(document.getElementById(`ifs_d_${i}`).value),
                    parseFloat(document.getElementById(`ifs_e_${i}`).value),
                    parseFloat(document.getElementById(`ifs_f_${i}`).value)
                ];
                transforms.push(transform);
            }
            
            // Parse probabilities
            const probStr = elements.ifsProbabilities.value.trim();
            const probabilities = probStr.split(',').map(p => parseFloat(p.trim()));
            
            // Validate probabilities
            if (probabilities.length !== count) {
                throw new Error(`Number of probabilities (${probabilities.length}) must match number of transformations (${count})`);
            }
            
            const probSum = probabilities.reduce((sum, p) => sum + p, 0);
            if (Math.abs(probSum - 1.0) > 0.1) {
                throw new Error(`Probabilities must sum to ~1.0 (current sum: ${probSum.toFixed(3)})`);
            }
            
            return {
                transforms,
                probabilities,
                parseMode: elements.ifsParseMode.value
            };
        }

        // Event Listeners
        elements.generateBtn.addEventListener('click', generateFractal);
        elements.downloadBtn.addEventListener('click', downloadPNG);
        
        // Method and preset change handlers
        elements.fractalMethod.addEventListener('change', updateControlVisibility);
        elements.escapeTimeType.addEventListener('change', updateEscapeTimeControls);
        elements.chaosGameType.addEventListener('change', updateChaosGameDefaults);
        elements.ifsType.addEventListener('change', loadIFSPreset);
        elements.ifsTransformCount.addEventListener('change', createTransformationInputs);
        
        elements.zoomInBtn.addEventListener('click', () => zoomIn());
        elements.zoomOutBtn.addEventListener('click', zoomOut);
        elements.resetViewBtn.addEventListener('click', resetView);

        // Canvas click events - only for escape-time fractals
        elements.canvas.addEventListener('click', (e) => {
            if (isLoading) return;
            
            const method = elements.fractalMethod.value;
            if (method !== 'escape_time') return; // Only escape-time fractals support zooming
            
            const rect = elements.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            zoomIn(x, y);
        });

        elements.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (isLoading) return;
            
            const method = elements.fractalMethod.value;
            if (method !== 'escape_time') return; // Only escape-time fractals support zooming
            
            zoomOut();
        });

        // Canvas size change
        elements.canvasSize.addEventListener('change', function() {
            const size = parseInt(this.value);
            elements.canvas.width = size;
            elements.canvas.height = size;
            
            if (currentFractal) {
                generateFractal();
            }
        });

        // Real-time parameter updates for Julia set
        elements.juliaReal.addEventListener('input', () => {
            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            if (method === 'escape_time' && fractalType === 'julia' && !isLoading) {
                clearTimeout(window.juliaTimeout);
                window.juliaTimeout = setTimeout(generateFractal, 500);
            }
        });

        elements.juliaImag.addEventListener('input', () => {
            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            if (method === 'escape_time' && fractalType === 'julia' && !isLoading) {
                clearTimeout(window.juliaTimeout);
                window.juliaTimeout = setTimeout(generateFractal, 500);
            }
        });

        // Color scheme real-time update
        elements.colorScheme.addEventListener('change', () => {
            if (currentFractal && !isLoading) {
                generateFractal();
            }
        });

        // Initialize application
        initWasm();
        updateControlVisibility();
        updateStatus();
    </script>
</body>
</html>