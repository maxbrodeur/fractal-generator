<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fractal Generator - Interactive WebAssembly</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            color: #333;
            overflow: hidden; /* lock page scroll; sidebar will scroll */
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: 100vh; /* full viewport */
            width: 100%;
            height: 100vh;
            overflow: hidden;
            overflow: hidden;
        }
        
        .app-container.sidebar-collapsed .sidebar {
            width: 40px;
        }
        
        /* Base sidebar styling (desktop and larger) */
        .sidebar {
            background: white;
            padding: 0 1rem 1rem 1rem;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
            overflow: hidden; /* internal scroll container handles scrolling */
        }

        .sidebar-header {
            position: sticky;
            top: 0;
            background: white;
            padding-top: 1rem;
            z-index: 5;
        }

        .sidebar-content { /* new flex container to enable sidebar-scroll growth */
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0;
        }

        .sidebar-scroll {
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-top: 0.5rem;
            flex: 1 1 auto;
            min-height: 0; /* allow flex scroll */
        }
        
        .sidebar.collapsed {
            width: 40px;
            padding: 0.5rem;
            overflow: hidden;
        }
        
        .sidebar.collapsed .sidebar-content {
            display: none;
        }
        
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            flex-wrap: wrap;
        }

        /* Restore layout for grouped header action buttons */
        .header-actions {
            display: flex;
            align-items: stretch;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }
        /* Stack chaos map buttons vertically */
        #chaosMapButtons.header-actions { flex-direction: column; }
        .header-actions .btn { flex: 1 1 auto; }
        
        .map-stats span {
            background: #e2e8f0;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        
        .parameter-editor {
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .parameter-section {
            margin-bottom: 1rem;
        }
        
        .parameter-section:last-child {
            margin-bottom: 0;
        }
        
        .parameter-label {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 0.5rem;
            display: block;
        }
        
        .parameter-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 0.5rem;
        }
        
        .parameter-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .parameter-input-group label {
            font-size: 0.75rem;
            color: #718096;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        
        .parameter-input-group input {
            width: 100%;
            padding: 0.25rem;
            font-size: 0.8rem;
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        
        .parameter-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .parameter-controls .btn {
            flex: 1;
            min-width: 80px;
        }
        
        .saved-maps-select {
            margin-bottom: 0.5rem;
        }
        
        .saved-map-controls {
            display: flex;
            gap: 0.5rem;
        }
        
        .saved-map-controls .btn {
            flex: 1;
        }
        
        /* Mobile responsiveness for chaotic map display */
        @media (max-width: 768px) {
            .equation-section {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .equation-label {
                margin-bottom: 0.25rem;
            }
            
            .map-stats {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .parameter-inputs {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .parameter-controls {
                flex-direction: column;
            }
        }
        
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #4a5568;
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .control-group input,
        .control-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }
        
        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .control-group small {
            display: block;
            margin-top: 0.25rem;
            color: #718096;
            font-size: 0.75rem;
            line-height: 1.2;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            justify-content: center; /* keep canvas centered */
            align-items: center;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            position: relative;
            overflow: hidden; /* fixed; no scroll */
        }
        
        /* Canvas outer container controls available space and recenters */
        .canvas-container {
            --canvas-max-width: 100%;
            --canvas-max-height: calc(100vh - 120px);
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            max-width: 1400px;
            flex: 0 0 auto;
            padding: 0;
            margin: 0;
        }

        /* Wrapper that will be scaled down if internal resolution is larger than viewport */
        .canvas-display-wrapper {
            position: relative;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            max-width: var(--canvas-max-width);
            max-height: var(--canvas-max-height);
            overflow: hidden; /* hide overflow when scaled */
        }

        /* The actual drawing canvas (high internal resolution) */
        #fractalCanvas {
            display: block;
            border-radius: 4px;
            image-rendering: pixelated;
            /* We'll control CSS size separately from pixel buffer */
        }

        /* Scaled class gets applied when we need to fit canvas */
        #fractalCanvas.scaled {
            box-shadow: 0 0 0 1px #444;
        }
    /* Removed old full-canvas overlay style */
        /* Compact equation overlay on canvas */
        .equation-overlay {
            position: absolute;
            left: 8px;
            bottom: 8px;
            background: rgba(0,0,0,0.6);
            color: #e5e7eb;
            padding: 6px 8px;
            border-radius: 6px;
            backdrop-filter: blur(2px);
            max-width: calc(100% - 16px);
            pointer-events: auto;
            display: none;
            z-index: 15;
        }
        .equation-overlay.show { display: block; }
        .equation-overlay .eq-line { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 12px; line-height: 1.3; }
        .equation-overlay .overlay-header { display:flex; align-items:center; gap:8px; margin-bottom:4px; font-size:12px; color:#cbd5e1; }
        .canvas-overlay-toggle {
            position: absolute;
            right: 8px;
            bottom: 8px;
            z-index: 6;
            background: rgba(0,0,0,0.5);
            color: #e5e7eb;
            border: none;
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
        }
        .canvas-overlay-toggle:hover { background: rgba(0,0,0,0.65); }
        
        .dynamic-controls {
            display: none;
        }
        
        .dynamic-controls.active {
            display: block;
        }
        
        .method-presets {
            margin-top: 1rem;
        }
        
        .method-controls {
            border-top: 1px solid #e2e8f0;
            padding-top: 1rem;
            margin-top: 1rem;
        }
        
        .julia-controls .input-group {
            justify-content: space-between;
        }
        
        .julia-controls input {
            width: 60px;
        }
        
        .ifs-transform {
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            background: #f7fafc;
        }
        
        .ifs-transform h4 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: #4a5568;
        }
        
        .ifs-params {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }
        
        .ifs-params input {
            width: 100%;
            padding: 0.25rem;
            font-size: 0.8rem;
            border: 1px solid #cbd5e0;
            border-radius: 3px;
        }
        
        .ifs-params label {
            font-size: 0.7rem;
            color: #718096;
            margin-bottom: 0.2rem;
        }
        
        /* Compact inline coefficient inputs for chaotic map equations */
        .inline-param {
            width: 52px;
            min-width: 48px;
            padding: 2px 4px;
            margin: 0 2px;
            font-size: 0.8rem;
            text-align: right;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        }
        .equation-formula { line-height: 1.8; }
        .equation-label { font-weight: 600; min-width: 56px; color:#1f2937; }
        
        /* Info icon tooltip for parameter help */
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            margin-left: 6px;
            border-radius: 50%;
            background: #e2e8f0;
            color: #334155;
            font-size: 12px;
            cursor: help;
            position: relative;
            user-select: none;
        }
        .info-icon::after {
            content: attr(data-tip);
            position: absolute;
            left: 50%;
            bottom: calc(100% + 8px);
            transform: translateX(-50%);
            white-space: normal;
            min-width: 180px;
            max-width: 280px;
            padding: 6px 8px;
            font-size: 0.75rem;
            line-height: 1.2;
            color: #fff;
            background: rgba(17,24,39,0.95);
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.12s ease;
            z-index: 20;
        }
        .info-icon:hover::after { opacity: 1; }
        
        /* Chaotic map history chips */
        .chaos-history {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        .chaos-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border: 1px solid #cbd5e1;
            border-radius: 999px;
            background: #f8fafc;
            font-size: 0.8rem;
            cursor: pointer;
            user-select: none;
        }
    .chaos-chip:hover { background:#eef2ff; border-color:#a5b4fc; }
    .chip-meta { color:#64748b; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .chip-type { font-weight: 600; color:#334155; }
    .chaos-chip .chip-actions { display:inline-flex; gap:4px; margin-left:4px; }
    .chip-btn { all: unset; cursor:pointer; color:#64748b; padding:0 4px; border-radius:4px; line-height:1; }
    .chip-btn:hover { background:#e2e8f0; color:#334155; }
    .chaos-chip.active { background:#e0e7ff; border-color:#6366f1; box-shadow: inset 0 0 0 1px #6366f1; }
    .history-header { display:flex; align-items:center; justify-content:space-between; font-size:0.8rem; color:#64748b; margin-top:6px; }
    .history-header button { all: unset; color:#64748b; cursor:pointer; padding:2px 6px; border-radius:4px; }
    .history-header button:hover { background:#e2e8f0; color:#334155; }
        
        .notification {
            position: fixed;
            top: 5rem;
            right: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }
        
        /* Hide notifications on mobile to prevent obstruction of parameters */
        @media (max-width: 768px) {
            .notification {
                display: none !important;
            }
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            background: #48bb78;
        }
        
        .notification.error {
            background: #f56565;
        }
        
        .notification.info {
            background: #4299e1;
        }

        /* Backdrop for mobile bottom sheet editor */
        .sheet-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(2px);
            display: none;
            z-index: 14;
        }
        
        /* Subtle batch progress indicator */
        .batch-progress {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(2px);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
            line-height: 1.2;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 15;
        }
        
        .batch-progress.visible {
            opacity: 1;
        }
        
        .batch-progress .batch-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .batch-progress .batch-spinner {
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Abort button styling */
        .abort-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 15;
            background: #e53e3e;
            color: #fff;
            font-size: 0.75rem;
            padding: 0.4rem 0.6rem;
            opacity: 0.9;
        }
        .abort-btn:hover { background:#c53030; }
        
        /* Enhanced Mobile Support */
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                grid-template-areas: 
                    "sidebar"
                    "main";
                height: 100vh;
            }
            
            .sidebar {
                max-height: 40vh; /* Limit sidebar height to 40% of viewport */
                padding: 1rem;
                order: 1;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-bottom: 1px solid #e2e8f0;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                transition: all 0.3s ease;
                overflow-y: auto; /* Enable scrolling for controls */
            }
            
            .sidebar.mobile-collapsed {
                max-height: 60px; /* Show just the header when collapsed */
                overflow: hidden;
            }
            
            .sidebar.mobile-collapsed .sidebar-content > *:not(.sidebar-header) {
                display: none; /* Hide all content except header when collapsed */
            }
            
            .main-content {
                padding: 0.5rem;
                order: 2;
                min-height: 60vh; /* Ensure main content takes at least 60% of viewport */
                flex: 1;
            }
            
            .canvas-container {
                width: 100%;
                height: 100%;
                max-width: 100vw;
                max-height: calc(100vh - 1rem);
            }
            
            #fractalCanvas {
                width: 100%;
                height: auto;
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
            }
            /* History chips become horizontally scrollable */
            .chaos-history {
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 4px;
                gap: 8px;
            }
            .chaos-chip { min-height: 36px; }

            /* Chip editor becomes a bottom sheet */
            #chipEditor {
                position: fixed !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                top: auto !important;
                max-width: 100vw !important;
                width: 100vw !important;
                border-radius: 12px 12px 0 0;
                background: rgba(17,24,39,0.98);
                color: #e5e7eb;
                box-shadow: 0 -8px 24px rgba(0,0,0,0.3);
                transform: translateY(100%);
                transition: transform 180ms ease;
                z-index: 20;
                max-height: 70vh;
                overflow-y: auto;
                padding-bottom: calc(10px + env(safe-area-inset-bottom));
            }
            #chipEditor.show { transform: translateY(0); }
            #chipEditor .overlay-header { display:flex; align-items:center; gap:8px; }
            #chipEditor .sheet-handle {
                width: 40px; height: 4px; background: #6b7280; border-radius: 2px;
                margin: 6px auto 8px auto;
                cursor: grab;
            }
            #chipEditor.dragging { transition: none !important; }
            

        }
        
        @media (max-width: 480px) {
            .header-actions {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .btn {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
                width: 100%;
            }
            
            .control-group input,
            .control-group select {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 0.75rem;
            }
            
            .sidebar-header h1 {
                font-size: 1.2rem;
                margin-bottom: 0.5rem;
            }
            
            .control-section {
                margin-bottom: 1rem;
            }
            
            .control-section h3 {
                font-size: 1rem;
                margin-bottom: 0.75rem;
            }
            
            /* Optimize touch targets */
            .sidebar-toggle {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            /* Better spacing for small screens */
            .control-group {
                margin-bottom: 0.75rem;
            }
            
            .ifs-params {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }
            
            .ifs-params input {
                padding: 0.5rem;
                font-size: 14px;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn {
                min-height: 44px; /* iOS recommended touch target */
                padding: 0.75rem 1rem;
            }
            
            .sidebar-toggle {
                min-width: 44px;
                min-height: 44px;
            }
            
            .control-group input,
            .control-group select {
                min-height: 44px;
                padding: 0.75rem;
            }
            .chip-btn { padding: 2px 8px; }
            
            /* Disable hover effects on touch devices */
            .btn:hover {
                transform: none;
            }
        }
        
        /* Mobile Header (shown only on mobile) */
        .mobile-header {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid #e2e8f0;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
        }
        
        .mobile-header h1 {
            font-size: 1.2rem;
            margin: 0;
            color: #1f2937;
        }
        
        .mobile-header-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .mobile-quick-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
        }
        
        .mobile-menu-btn {
            background: #f8fafc;
            color: #374151;
            border: 1px solid #d1d5db;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 1.1rem;
            cursor: pointer;
        }
        
        /* Mobile styles - transform existing sidebar */
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr; /* Single column on mobile */
            }
            
            .mobile-header {
                display: flex; /* Show mobile header */
            }
            
            .sidebar {
                position: fixed !important;
                top: 60px !important; /* Below mobile header */
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100% !important;
                height: calc(100vh - 60px) !important;
                max-height: calc(100vh - 60px) !important;
                z-index: 999;
                transform: translateX(-100%); /* Hidden by default */
                transition: transform 0.3s ease;
                border-radius: 0;
                box-shadow: 0 2px 20px rgba(0,0,0,0.3);
                padding: 0 1rem 1rem 1rem;
                overflow: visible !important; /* Allow content to be visible */
            }
            
            .sidebar.mobile-open {
                transform: translateX(0); /* Show when toggled */
            }
            
            .sidebar-toggle {
                display: none; /* Hide desktop toggle on mobile */
            }
            
            .main-content {
                margin-top: 60px; /* Space for mobile header */
                grid-column: 1; /* Full width */
            }
            
            /* Ensure canvas is visible below mobile controls */
            .canvas-container {
                padding-top: 0;
            }
            
            /* Adjust sidebar content for mobile */
            .sidebar-content {
                padding-top: 1rem !important;
                height: 100% !important; /* Fill the mobile sidebar height */
                display: flex !important;
                flex-direction: column !important;
                min-height: 0 !important;
            }
            
            .sidebar-header {
                flex-shrink: 0 !important; /* Don't shrink the header */
            }
            
            .sidebar-scroll {
                flex: 1 !important; /* Take remaining space */
                overflow-y: auto !important; /* Enable scrolling */
                -webkit-overflow-scrolling: touch; /* Smooth iOS scrolling */
                padding-bottom: 2rem; /* Extra padding at bottom */
                min-height: 0 !important; /* Allow flex shrinking */
                height: auto !important; /* Let it size properly */
                display: block !important; /* Ensure it's a block element */
            }
            
            .sidebar-header h1 {
                display: none; /* Hide duplicate title */
            }
            
            /* Force control elements to be visible on mobile */
            .control-section {
                margin-bottom: 1rem !important;
                padding: 0.5rem 0 !important;
            }
            
            .control-section h3 {
                font-size: 1rem !important;
                margin-bottom: 0.75rem !important;
                color: #374151 !important;
            }
            
            .control-group {
                margin-bottom: 0.75rem !important;
                min-height: auto !important;
            }
            
            .control-group label {
                display: block !important;
                margin-bottom: 0.25rem !important;
                font-weight: 500 !important;
                font-size: 0.9rem !important;
            }
            
            .control-group select,
            .control-group input {
                width: 100% !important;
                padding: 0.5rem !important;
                border: 1px solid #d1d5db !important;
                border-radius: 0.375rem !important;
                font-size: 1rem !important;
                background: white !important;
                min-height: 2.5rem !important;
                box-sizing: border-box !important;
            }
            
            .btn {
                min-height: 2.5rem !important;
                padding: 0.5rem 1rem !important;
                font-size: 0.9rem !important;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        
        <aside class="sidebar" id="sidebar">
            <button class="sidebar-toggle" id="sidebarToggle">←</button>
            <div class="sidebar-content">
                <div class="sidebar-header">
                    <h1>Fractal Generator</h1>
                    
                    <!-- Standard fractal generation buttons (shown for all methods except Random Chaos Finder) -->
                    <div class="header-actions" id="standardButtons">
                        <button class="btn" id="generateBtn" style="flex: 1;">
                            Generate Fractal
                        </button>
                    </div>
                    
                    <!-- Chaos Map specific buttons (shown only for Random Chaos Finder) -->
                    <div class="header-actions" id="chaosMapButtons" style="display: none;">
                        <button class="btn" id="generateAndPlotBtn" style="flex: 1;">
                            Find & Plot Chaotic Map
                        </button>
                        <button class="btn btn-secondary" id="generateMapBtn">
                            Find New Chaotic Map
                        </button>
                        <button class="btn btn-secondary" id="plotMapBtn" disabled>
                            Plot
                        </button>
                    </div>
                    
                    <!-- Always visible download button -->
                    <div class="header-actions" id="downloadSection">
                        <button class="btn btn-secondary" id="downloadBtn" disabled>
                            Download PNG
                        </button>
                    </div>
                </div>
                <div class="sidebar-scroll">
            <div class="control-section">
                <h3>Generation Method</h3>
                <div class="control-group">
                    <select id="fractalMethod">
                        <option value="random_chaos">Random Chaos Finder</option>
                        <option value="escape_time">Escape-Time Fractals</option>
                        <option value="chaos_game">Chaos Game</option>
                        <option value="ifs">Iterated Function Systems (IFS)</option>
                    </select>
                </div>
                
                <!-- Escape-Time Fractal Presets -->
                <div id="escapeTimePresets" class="control-group method-presets" style="display: none;">
                    <label>Fractal Type</label>
                    <select id="escapeTimeType">
                        <option value="mandelbrot">Mandelbrot Set</option>
                        <option value="julia">Julia Set</option>
                        <option value="burning_ship">Burning Ship</option>
                    </select>
                </div>
                
                <!-- Chaos Game Presets -->
                <div id="chaosGamePresets" class="control-group method-presets" style="display: none;">
                    <label>Chaos Game Pattern</label>
                    <select id="chaosGameType">
                        <option value="sierpinski">Sierpinski Triangle</option>
                        <option value="sierpinski_carpet">Sierpinski Carpet</option>
                        <option value="vicsek">Vicsek Square</option>
                        <option value="t_square">T-Square</option>
                        <option value="techs">Techs Pattern</option>
                        <option value="webs">Web Pattern</option>
                    </select>
                </div>
                
                <!-- IFS Presets -->
                <div id="ifsPresets" class="control-group method-presets" style="display: none;">
                    <label>IFS Pattern</label>
                    <select id="ifsType">
                        <option value="fern">Barnsley Fern</option>
                        <option value="dragon">Dragon Curve</option>
                        <option value="leaf">Maple Leaf</option>
                        <option value="christmas">Christmas Tree</option>
                        <option value="spiral">Spiral</option>
                        <option value="mandelbrot_like">Mandelbrot-like IFS</option>
                        <option value="sierpinski_ifs">Sierpinski Triangle (IFS)</option>
                    </select>
                </div>
                
                <!-- Random Chaos Methods -->
                <div id="chaosFinderMethods" class="control-group method-presets">
                    <label>Map Type</label>
                    <select id="chaosFinderType">
                        <option value="quadratic">Quadratic Map</option>
                        <option value="cubic">Cubic Map</option>
                    </select>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Visual Parameters</h3>
                
                <div class="control-group">
                    <label>Canvas Size <span class="info-icon" data-tip="Sets the internal render resolution. Larger sizes produce sharper images but take longer and use more memory.">i</span></label>
                    <select id="canvasSize">
                        <option value="400">400x400</option>
                        <option value="600">600x600</option>
                        <option value="800">800x800</option>
                        <option value="1024">1024x1024</option>
                        <option value="2048" selected>2048x2048 (2K)</option>
                        <option value="4096">4096x4096 (4K)</option>
                        <option value="8192">8192x8192 (8K)</option>
                        <option value="16384">16384x16384 (16K)</option>
                        <option value="32768">32768x32768 (32K)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Aspect Ratio <span class="info-icon" data-tip="Controls the width:height ratio of the canvas. Landscape, Portrait, or Square.">i</span></label>
                    <select id="aspectRatio">
                        <option value="square">Square (1:1)</option>
                        <option value="portrait">Portrait (3:4)</option>
                        <option value="landscape" selected>Landscape (4:3)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Color Scheme <span class="info-icon" data-tip="Choose from precomputed color lookup tables that map densities to colors.">i</span></label>
                    <select id="colorScheme">
                        <option value="0">Fire</option>
                        <option value="1">Jet</option>
                        <option value="2">Prism</option>
                        <option value="3">Turbo</option>
                        <option value="4">Color Wheel</option>
                        <option value="5">GNU Plot</option>
                        <option value="6">BMY</option>
                        <option value="7">Plasma</option>
                        <option value="8">Inferno</option>
                        <option value="9">Viridis</option>
                        <option value="10">Neon</option>
                        <option value="11">Pastel</option>
                        <option value="12">Magma</option>
                        <option value="13">Cividis</option>
                        <option value="14">Gray</option>
                        <option value="15" selected>Cubehelix</option>
                        <option value="16">Blue-Orange</option>
                        <option value="17">Heat</option>
                        <option value="18">Ice</option>
                        <option value="19">White Fire</option>
                        <option value="20">White Heat</option>
                        <option value="21">White Blue</option>
                        <option value="22">White Viridis</option>
                        <option value="23">White Magma</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Density Softness (log) <span class="info-icon" data-tip="Adjusts the logarithmic mapping from density to brightness. Higher = softer (brighter low densities).">i</span></label>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <input type="range" id="densitySoftness" min="0.01" max="500" step="0.01" value="1" style="flex:1;">
                        <input type="number" id="densitySoftnessInput" min="0.01" max="500" step="0.01" value="1" style="width:80px;">
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Background Color <span class="info-icon" data-tip="Applied behind the fractal. Use min-density color to blend with colormap or None for raw colormap background.">i</span></label>
                    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                        <input type="color" id="backgroundColor" value="#000000" style="width:40px; height:32px; padding:0; border:1px solid #cbd5e1; border-radius:4px;">
                        <label style="display:flex; gap:6px; align-items:center; font-size:0.8rem;">
                            <input type="checkbox" id="bgUseMinDensityColor"> Use min-density color
                        </label>
                        <label style="display:flex; gap:6px; align-items:center; font-size:0.8rem;">
                            <input type="checkbox" id="noBackgroundColor"> None
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Chaotic Map</h3>
                
                <!-- Random Chaos Finder specific controls -->
                <div id="chaosFinderControls" class="method-controls">
                    <div class="control-group">
                        <label>Plot Points <span class="info-icon" data-tip="Total points to draw when plotting a discovered chaotic map. Auto-Convergence can override this.">i</span></label>
                        <input type="number" id="chaosPlotPoints" value="10000000" min="100000" step="100000" max="100000000">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="chaosConvergenceMode" checked>
                            Auto-Convergence Mode <span class="info-icon" data-tip="Plot in batches until coverage stabilizes (low growth). Helps choose sufficient points automatically.">i</span>
                        </label>
                    </div>
                </div>
                
                <!-- Chaotic Map History Only -->
                <div id="chaoticMapDisplay" class="method-controls" style="display: none;">
                    <div class="control-group">
                        <div class="history-header"><span>Recent</span><button id="clearChaosHistoryBtn" title="Clear recent maps">Clear</button></div>
                        <div id="chaosHistory" class="chaos-history" aria-label="Recent chaotic maps" title="Recent chaotic maps (click to load)"></div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Advanced Parameters</h3>
                
                <!-- Universal Parameters -->
                <div class="control-group">
            <label>Iterations <span class="info-icon" data-tip="Number of iterations or points. Hidden for Random Chaos Finder where plotting is iterative.">i</span></label>
                    <input type="number" id="iterations" value="50000" min="1000" max="1000000" step="1000">
                </div>
                
                <div class="control-group">
            <label>Batch Size <span class="info-icon" data-tip="Points per batch during plotting. Larger increases memory; smaller may slow down.">i</span></label>
                    <input type="number" id="chaosBatchSize" value="1000000" min="1000000" step="1000000" max="10000000">
                </div>
                <div class="control-group">
            <label>Test Points <span class="info-icon" data-tip="Points used to estimate chaos (Lyapunov). Higher is slower but more accurate.">i</span></label>
                    <input type="number" id="chaosTestPoints" value="100000" min="10000" max="1000000" step="10000">
                </div>
                <div class="control-group">
            <label>Discard Points <span class="info-icon" data-tip="Transient iterations dropped before analysis to allow convergence to the attractor.">i</span></label>
                    <input type="number" id="chaosDiscardPoints" value="10000" min="1000" max="50000" step="1000">
                </div>
                <div class="control-group">
            <label>Search Attempts <span class="info-icon" data-tip="Maximum parameter samples to try when searching for a chaotic map.">i</span></label>
                    <input type="number" id="searchAttempts" value="1000" min="100" max="10000" step="100">
                </div>
                <div class="control-group">
            <label>Randomization Type <span class="info-icon" data-tip="Continuous samples coefficients from ranges; Discrete samples from a fixed alphabet.">i</span></label>
                    <select id="chaosRandomizationType">
                        <option value="continuous">Continuous</option>
                        <option value="discrete">Discrete (Alphabet mode)</option>
                    </select>
                </div>

                <!-- Auto-Convergence Threshold Controls (visible only when auto-convergence enabled) -->
    <div id="convergenceAdvancedControls" style="display:none; border:1px solid #e2e8f0; padding:0.75rem; border-radius:6px; background:#f8fafc; margin-top:0.5rem;">
            <div class="control-group" style="margin-bottom:0.5rem;">
        <label style="margin-bottom:0.25rem;">Auto-Convergence Thresholds Δ <span class="info-icon" data-tip="Stop when BOTH relative growth (%) and absolute new pixels fall below thresholds for consecutive batches.">i</span></label>
            </div>
                    <div class="parameter-inputs" style="grid-template-columns:repeat(auto-fit,minmax(110px,1fr)); gap:0.5rem;">
                        <div class="parameter-input-group">
                            <label for="chaosRelGrowthThreshold">Rel Growth %</label>
                            <input type="number" id="chaosRelGrowthThreshold" value="0.05" step="0.01" min="0.001" title="Relative growth percent threshold between batches (default 0.05%)">
                        </div>
                        <div class="parameter-input-group">
                            <label for="chaosAbsGrowthPixels">Abs Pixels</label>
                            <input type="number" id="chaosAbsGrowthPixels" value="50" step="10" min="1" title="Minimum new pixels threshold (default 50)">
                        </div>
                    </div>
                </div>
                
                <!-- Escape-Time Fractal Controls -->
                <div id="escapeTimeControls" class="method-controls" style="display: none;">
                    <!-- Julia Set Controls -->
                    <div id="juliaControls" class="dynamic-controls julia-controls">
                        <div class="control-group">
                            <label>Complex Parameter</label>
                            <div class="input-group">
                                <input type="number" id="juliaReal" value="-0.7" step="0.01">
                                <span>+</span>
                                <input type="number" id="juliaImag" value="0.27015" step="0.01">
                                <span>i</span>
                            </div>
                            <small>Real and imaginary components of Julia set parameter</small>
                        </div>
                    </div>
                </div>
                
                <!-- Chaos Game Controls -->
                <div id="chaosGameControls" class="method-controls" style="display: none;">
                    <div class="control-group">
                        <label>Compression Ratio</label>
                        <input type="number" id="compressionRatio" value="0.5" min="0.1" max="1.0" step="0.05">
                        <small>Fraction of distance to jump toward vertex (0.1-1.0)</small>
                    </div>
                    <div class="control-group">
                        <label>Number of Vertices</label>
                        <input type="number" id="numberOfVertices" value="3" min="3" max="10" step="1">
                        <small>Number of vertices for chaos game (3=triangle, 4=square, etc.)</small>
                    </div>
                    <div class="control-group">
                        <label>Rotation Angle</label>
                        <input type="number" id="rotationAngle" value="0" min="-3.14" max="3.14" step="0.1">
                        <small>Rotation angle in radians</small>
                    </div>
                    <div class="control-group">
                        <label>Rule Length</label>
                        <input type="number" id="ruleLength" value="0" min="0" max="10" step="1">
                        <small>Number of previous vertex choices to track</small>
                    </div>
                    <div class="control-group">
                        <label>Rule Offset</label>
                        <input type="number" id="ruleOffset" value="0" min="-5" max="5" step="1">
                        <small>Forbidden offset from last vertex</small>
                    </div>
                    <div class="control-group">
                        <label>Rule Symmetry</label>
                        <select id="ruleSymmetry">
                            <option value="false">No</option>
                            <option value="true">Yes</option>
                        </select>
                        <small>Apply symmetric vertex selection restrictions</small>
                    </div>
                    <div class="control-group" id="techsSkewGroup" style="display: none;">
                        <label>Techs Skew</label>
                        <input type="number" id="techsSkew" value="0" min="-3" max="3" step="1">
                        <small>Variable offset parameter for Techs pattern</small>
                    </div>
                </div>
                
                <!-- IFS Controls -->
                <div id="ifsControls" class="method-controls" style="display: none;">
                    <div class="control-group">
                        <label>Starting Point X</label>
                        <input type="number" id="ifsStartX" value="0" step="0.1">
                        <small>Initial X coordinate for IFS iteration</small>
                    </div>
                    <div class="control-group">
                        <label>Starting Point Y</label>
                        <input type="number" id="ifsStartY" value="0" step="0.1">
                        <small>Initial Y coordinate for IFS iteration</small>
                    </div>
                    <div class="control-group">
                        <label>Parsing Mode</label>
                        <select id="ifsParseMode">
                            <option value="borke">Borke (a*x + b*y + e, c*x + d*y + f)</option>
                            <option value="regular">Regular (a*x + b*y + c, d*x + e*y + f)</option>
                        </select>
                        <small>How to interpret transformation parameters</small>
                    </div>
                    <div class="control-group">
                        <label>Number of Transformations</label>
                        <select id="ifsTransformCount">
                            <option value="2">2 Transformations</option>
                            <option value="3">3 Transformations</option>
                            <option value="4" selected>4 Transformations</option>
                        </select>
                        <small>How many affine transformations to use</small>
                    </div>
                    
                    <!-- Transformation parameters -->
                    <div id="ifsTransformations">
                        <!-- Will be populated dynamically -->
                    </div>
                    
                    <div class="control-group">
                        <label>Probabilities</label>
                        <input type="text" id="ifsProbabilities" value="0.01, 0.07, 0.07, 0.85" placeholder="e.g., 0.25, 0.25, 0.25, 0.25">
                        <small>Comma-separated probability weights (must sum to ~1.0)</small>
                    </div>
                </div>
            </div>

                
            </div>
            
            </div>
        </aside>
        
        <!-- Mobile Header (overlay for mobile only) -->
        <div id="mobileHeader" class="mobile-header">
            <h1>Fractal Generator</h1>
            <div class="mobile-header-buttons">
                <button id="mobileQuickGenerate" class="mobile-quick-btn">Generate</button>
                <button id="mobileMenuToggle" class="mobile-menu-btn">≡</button>
            </div>
        </div>
        
        <main class="main-content">
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-display-wrapper" id="canvasDisplayWrapper">
                    <canvas id="fractalCanvas" width="2048" height="2048"></canvas>
                    <!-- Floating toggle to restore controls when sidebar is collapsed -->
                    <button id="sidebarFab" class="btn" title="Show controls" aria-label="Show controls" style="display:none; position:fixed; top:12px; left:12px; z-index:30; padding:6px 10px; border-radius:999px; backdrop-filter: blur(6px); background: rgba(17,24,39,0.8); color:#e5e7eb; border:1px solid rgba(229,231,235,0.25); box-shadow: 0 2px 8px rgba(0,0,0,0.25);">
                        ☰
                    </button>
                    <div id="chipEditor" class="equation-overlay" style="max-width: min(560px, calc(100% - 16px)); display:none;">
                        <div class="sheet-handle" aria-hidden="true"></div>
                        <div class="overlay-header">Edit Coefficients</div>
                        <div class="eq-line"><span class="eq-prefix">xₙ₊₁ = </span><span id="editorX"></span></div>
                        <div class="eq-line"><span class="eq-prefix">yₙ₊₁ = </span><span id="editorY"></span></div>
                        <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
                            <button id="applyEditBtn" class="btn btn-secondary">Apply</button>
                            <button id="cancelEditBtn" class="btn">Close</button>
                            <span style="flex:1 1 auto"></span>
                            <button id="copyParametersBtn" class="btn btn-secondary" title="Copy parameters">Copy</button>
                            <button id="pasteParametersBtn" class="btn btn-secondary" title="Paste parameters">Paste</button>
                        </div>
                    </div>
                    <div id="sheetBackdrop" class="sheet-backdrop" aria-hidden="true"></div>
                    <button id="abortBatchesBtn" class="btn abort-btn" style="display:none;" title="Abort iterative plotting and keep current image">Abort</button>
                    <div class="batch-progress" id="batchProgress">
                        <div class="batch-info">
                            <div class="batch-spinner"></div>
                            <span id="batchText">Preparing...</span>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Debug Helpers - Load before main script -->
    <script src="debug-helpers.js"></script>
    
    <script>
        // Application State
        let generator = null;
        let isLoading = false;
    let currentFractal = null;
    let lastAccumulatedDensity = null; // cached density for dynamic recolor
    let abortRequested = false; // Abort flag for iterative batch processing
    let activeGenerationToken = 0; // Monotonically increasing token to cancel previous runs
        
        // Chaotic map state for separate generation and plotting
        let storedChaoticMap = null;
    const CHAOS_HISTORY_LIMIT = 6;
    const CHAOS_HISTORY_STORAGE_KEY = 'fg-chaos-history.v1';
    let chaosHistory = [];
    let activeHistoryIndex = -1;

        // Mobile Interface Management - Reuses Desktop Sidebar
        function initializeMobileInterface() {
            console.log('Mobile interface initializing...');
            
            const mobileMenuToggle = document.getElementById('mobileMenuToggle');
            const mobileQuickGenerate = document.getElementById('mobileQuickGenerate');
            const sidebar = document.getElementById('sidebar');
            
            // Toggle mobile sidebar (shows/hides existing desktop sidebar)
            if (mobileMenuToggle && sidebar) {
                mobileMenuToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('mobile-open');
                    mobileMenuToggle.textContent = sidebar.classList.contains('mobile-open') ? '✕' : '≡';
                });
            }
            
            // Quick generate button (always visible)
            if (mobileQuickGenerate) {
                mobileQuickGenerate.addEventListener('click', async () => {
                    console.log('Mobile: Quick generate');
                    
                    try {
                        await generateAndPlotChaoticMap();
                    } catch (error) {
                        console.error('Failed to generate fractal:', error);
                        alert('Failed to generate fractal. Please try again.');
                    }
                });
            }
            
            // Close mobile sidebar when user taps outside (optional enhancement)
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 768 && sidebar && sidebar.classList.contains('mobile-open')) {
                    if (!sidebar.contains(e.target) && !mobileMenuToggle.contains(e.target)) {
                        sidebar.classList.remove('mobile-open');
                        mobileMenuToggle.textContent = '≡';
                    }
                }
            });
        }

    function saveChaosHistory() {
        try {
            const payload = chaosHistory.slice(0, CHAOS_HISTORY_LIMIT);
            localStorage.setItem(CHAOS_HISTORY_STORAGE_KEY, JSON.stringify(payload));
        } catch (e) { console.warn('Failed to persist chaos history', e); }
    }

    function loadChaosHistory() {
        try {
            const raw = localStorage.getItem(CHAOS_HISTORY_STORAGE_KEY);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
                // Basic shape validation
                chaosHistory = parsed.filter(e => e && Array.isArray(e.x_params) && Array.isArray(e.y_params));
                activeHistoryIndex = chaosHistory.length ? 0 : -1;
            }
        } catch (e) { console.warn('Failed to load chaos history', e); }
    }
        
        // Constants
        const DEFAULT_BATCH_SIZE = 1000000; // 1M points per batch for optimal memory usage
        const BOUNDS_SAMPLE_SIZE = 100000;   // 100K points for bounds calculation
        
        // View State for zooming/panning
        let viewState = {
            centerX: 0,
            centerY: 0,
            zoom: 1.0,
            fractalType: 'mandelbrot'
        };

        // DOM Elements
        const elements = {
            canvas: document.getElementById('fractalCanvas'),
            container: document.getElementById('canvasContainer'),
            canvasDisplayWrapper: document.getElementById('canvasDisplayWrapper'),
            
            // Batch progress indicator
            batchProgress: document.getElementById('batchProgress'),
            batchText: document.getElementById('batchText'),
            
            // Button containers
            standardButtons: document.getElementById('standardButtons'),
            chaosMapButtons: document.getElementById('chaosMapButtons'),
            downloadSection: document.getElementById('downloadSection'),
            
            // Buttons
            generateBtn: document.getElementById('generateBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            
            // Chaos map specific buttons
            generateAndPlotBtn: document.getElementById('generateAndPlotBtn'),
            generateMapBtn: document.getElementById('generateMapBtn'),
            plotMapBtn: document.getElementById('plotMapBtn'),
            // Editor overlay elements
            chipEditor: document.getElementById('chipEditor'),
            editorX: document.getElementById('editorX'),
            editorY: document.getElementById('editorY'),
            applyEditBtn: document.getElementById('applyEditBtn'),
            cancelEditBtn: document.getElementById('cancelEditBtn'),
            
            // Method and preset selectors
            fractalMethod: document.getElementById('fractalMethod'),
            escapeTimePresets: document.getElementById('escapeTimePresets'),
            chaosGamePresets: document.getElementById('chaosGamePresets'),
            ifsPresets: document.getElementById('ifsPresets'),
            chaosFinderMethods: document.getElementById('chaosFinderMethods'),
            escapeTimeType: document.getElementById('escapeTimeType'),
            chaosGameType: document.getElementById('chaosGameType'),
            ifsType: document.getElementById('ifsType'),
            chaosFinderType: document.getElementById('chaosFinderType'),
            
            // Universal parameters
            iterations: document.getElementById('iterations'),
            canvasSize: document.getElementById('canvasSize'),
            aspectRatio: document.getElementById('aspectRatio'),
            colorScheme: document.getElementById('colorScheme'),
            iterationsHelp: document.getElementById('iterationsHelp'),
            
            // Method-specific control sections
            escapeTimeControls: document.getElementById('escapeTimeControls'),
            chaosGameControls: document.getElementById('chaosGameControls'),
            ifsControls: document.getElementById('ifsControls'),
            chaosFinderControls: document.getElementById('chaosFinderControls'),
            
            // Escape-time fractal controls
            juliaControls: document.getElementById('juliaControls'),
            juliaReal: document.getElementById('juliaReal'),
            juliaImag: document.getElementById('juliaImag'),
            
            // Chaos game controls
            compressionRatio: document.getElementById('compressionRatio'),
            rotationAngle: document.getElementById('rotationAngle'),
            ruleLength: document.getElementById('ruleLength'),
            ruleOffset: document.getElementById('ruleOffset'),
            ruleSymmetry: document.getElementById('ruleSymmetry'),
            techsSkew: document.getElementById('techsSkew'),
            techsSkewGroup: document.getElementById('techsSkewGroup'),
            
            // IFS controls
            ifsStartX: document.getElementById('ifsStartX'),
            ifsStartY: document.getElementById('ifsStartY'),
            ifsParseMode: document.getElementById('ifsParseMode'),
            ifsTransformCount: document.getElementById('ifsTransformCount'),
            ifsTransformations: document.getElementById('ifsTransformations'),
            ifsProbabilities: document.getElementById('ifsProbabilities'),
            
            // Chaos finder controls
            chaosPlotPoints: document.getElementById('chaosPlotPoints'),
            chaosBatchSize: document.getElementById('chaosBatchSize'),
            chaosTestPoints: document.getElementById('chaosTestPoints'),
            chaosDiscardPoints: document.getElementById('chaosDiscardPoints'),
            chaosRandomizationType: document.getElementById('chaosRandomizationType'),
            searchAttempts: document.getElementById('searchAttempts'),
            convergenceAdvancedControls: document.getElementById('convergenceAdvancedControls'),
            relGrowthThreshold: document.getElementById('chaosRelGrowthThreshold'),
            absGrowthPixels: document.getElementById('chaosAbsGrowthPixels'),
            
            // Visual controls
            backgroundColor: document.getElementById('backgroundColor'),
            
            // Convergence detection controls
            chaosConvergenceMode: document.getElementById('chaosConvergenceMode'),
            
            // Chaotic map display elements (history only)
            chaoticMapDisplay: document.getElementById('chaoticMapDisplay'),
            // legacy sidebar fields removed; keep optional references for clipboard buttons if present
            copyParametersBtn: document.getElementById('copyParametersBtn'),
            pasteParametersBtn: document.getElementById('pasteParametersBtn')
        };

        // Abort button handler
        const abortBtnEl = document.getElementById('abortBatchesBtn');
        if (abortBtnEl) {
            abortBtnEl.addEventListener('click', () => {
                if (!abortRequested) {
                    abortRequested = true;
                    abortBtnEl.textContent = 'Aborting...';
                    abortBtnEl.disabled = true;
                    console.log('⛔ User requested abort of iterative batches');
                }
            });
        }

        // Initialize WebAssembly (attempt to load, handle gracefully if not available)
        async function initWasm() {
            console.log('🔧 Initializing WebAssembly module...');
            
            try {
                const wasmModule = await import('./pkg/fractal_wasm.js');
                await wasmModule.default();
                const { FractalGenerator, Rule, ColorScheme, FractalPresets, ChaoticAccumulator } = wasmModule;
                
                // Store globally for use in other functions and debug helpers
                window.FractalGenerator = FractalGenerator;
                window.Rule = Rule;
                window.ColorScheme = ColorScheme;
                window.FractalPresets = FractalPresets;
                window.ChaoticAccumulator = ChaoticAccumulator; // expose accumulator
                
                generator = new FractalGenerator();
                showNotification('WebAssembly loaded successfully!', 'success');
                updateStatus();
                
                // Initialize canvas with default background on page load
                initializeCanvas(elements.canvas, elements.backgroundColor.value);
                
                console.log('✅ WASM initialized successfully');
                console.log('🔧 Debug tools available at window.debugFractal');
                
                // Run basic functionality check
                if (window.debugFractal) {
                    setTimeout(() => {
                        console.log('🧪 Running automatic module verification...');
                        window.debugFractal.checkModuleStatus();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('❌ WebAssembly initialization failed:', error);
                
                // Enhanced error reporting
                const errorDetails = {
                    message: error.message,
                    name: error.name,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                
                // Log detailed error for debugging
                if (window.debugFractal) {
                    window.debugFractal.logError('WASM_INIT_FAILURE', JSON.stringify(errorDetails));
                }
                
                // User-friendly error message with actionable advice
                let userMessage = 'WebAssembly failed to load. ';
                
                if (window.location.protocol === 'file:') {
                    userMessage += 'Please use a web server (not file://) to run this application.';
                } else if (error.message.includes('CORS')) {
                    userMessage += 'CORS issue detected. Ensure you\'re running from a proper web server.';
                } else if (error.message.includes('fetch')) {
                    userMessage += 'Network error. Check your internet connection and try refreshing.';
                } else {
                    userMessage += 'Check browser console for details or try refreshing the page.';
                }
                
                showNotification(userMessage, 'error');
                console.log('💡 Troubleshooting tips:');
                console.log('  1. Ensure you\'re using http://localhost:8000 (not file://)');
                console.log('  2. Check that the WebAssembly files were built correctly');
                console.log('  3. Try running: npm run build');
                console.log('  4. Use window.debugFractal.generateDebugReport() for detailed info');
            }
        }

        // UI Helper Functions
        // Simplified progress functions using only batch progress indicator
    function showBatchProgress(batchNumber, coveragePct = null, growthInfo = null, nonZero = null, totalElapsedMs = null) {
            if (elements.batchProgress && elements.batchText) {
                let txt = `Batch ${batchNumber}`;
                if (coveragePct !== null) {
                    txt += ` · coverage ${(coveragePct).toFixed(2)}%`;
                }
                if (growthInfo !== null) {
                    txt += ` · Δ ${growthInfo}`;
                }
                if (nonZero !== null) { txt += ` · lit ${nonZero.toLocaleString()}`; }
                if (totalElapsedMs !== null) { txt += ` · ${Math.round(totalElapsedMs)}ms`; }
                elements.batchText.textContent = txt;
                elements.batchProgress.classList.add('visible');
        const abortEl = document.getElementById('abortBatchesBtn');
        if (abortEl && !abortRequested) abortEl.style.display = 'inline-block';
            }
        }

        function hideBatchProgress() {
            if (elements.batchProgress) {
                elements.batchProgress.classList.remove('visible');
            }
        }

        function updateMainContentBackground() {
            const backgroundColor = elements.backgroundColor.value;
            const mainContent = document.querySelector('.main-content');
            const canvasContainer = document.querySelector('.canvas-container');
            
            if (mainContent) {
                mainContent.style.backgroundColor = backgroundColor;
            }
            
            if (canvasContainer) {
                canvasContainer.style.backgroundColor = backgroundColor;
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function showToast(message, duration = 3000) {
            showNotification(message, 'info');
        }

        function updateStatus() {
            // Status display removed
        }

        function setLoading(loading) {
            isLoading = loading;
            elements.generateBtn.disabled = loading;
            elements.downloadBtn.disabled = loading || !currentFractal;
            
            // Update chaos map buttons
            updateChaosMapButtonStates();
            
            if (loading) {
                elements.generateBtn.textContent = '⏳ Generating...';
                if (elements.generateAndPlotBtn) {
                    elements.generateAndPlotBtn.textContent = '⏳ Finding & Plotting...';
                }
                if (elements.generateMapBtn) {
                    elements.generateMapBtn.textContent = '⏳ Searching...';
                }
                if (elements.plotMapBtn && !elements.plotMapBtn.disabled) {
                    elements.plotMapBtn.textContent = '⏳ Plotting...';
                }
            } else {
                elements.generateBtn.textContent = 'Generate Fractal';
                if (elements.generateAndPlotBtn) {
                    elements.generateAndPlotBtn.textContent = 'Find & Plot Chaotic Map';
                }
                if (elements.generateMapBtn) {
                    elements.generateMapBtn.textContent = 'Find New Chaotic Map';
                }
                if (elements.plotMapBtn) {
                    elements.plotMapBtn.textContent = 'Plot';
                }
            }
        }

        // Update chaos map button states based on whether a map is stored
        function updateChaosMapButtonStates() {
            const hasStoredMap = storedChaoticMap !== null;
            elements.plotMapBtn.disabled = !hasStoredMap || isLoading;
            elements.generateMapBtn.disabled = isLoading;
            elements.generateAndPlotBtn.disabled = isLoading;
        }

        // Store chaotic map data for later plotting
        function storeChaoticMap(pointData, coefficients, chaosType, testPoints, discardPoints, useAlphabet, isCubic, originalPlotPoints = null) {
            storedChaoticMap = {
                type: chaosType,
                testPoints: testPoints,
                discardPoints: discardPoints,
                useAlphabet: useAlphabet,
                isCubic: isCubic,
                // Only store point data if we don't have coefficients (for fallback)
                pointData: coefficients ? null : pointData,
                coefficients: coefficients,
                // Store original plot points for reference only
                originalPlotPoints: originalPlotPoints || (pointData ? pointData.length / 2 : 0)
            };
            
            console.log('✅ Chaotic map stored:', {
                hasCoefficients: !!coefficients,
                hasXParams: !!(coefficients && coefficients.x_params),
                hasYParams: !!(coefficients && coefficients.y_params),
                xParamsLength: coefficients?.x_params?.length,
                yParamsLength: coefficients?.y_params?.length
            });

            // Push to history if coefficients exist
            try {
                // WASM getters return TypedArrays, not plain Arrays. Accept any array-like view.
                const toJsArray = (v) => {
                    if (!v) return null;
                    if (Array.isArray(v)) return v.slice();
                    if (ArrayBuffer.isView(v)) return Array.from(v);
                    return null;
                };
                const xArr = toJsArray(coefficients && coefficients.x_params);
                const yArr = toJsArray(coefficients && coefficients.y_params);
                if (xArr && yArr) {
                    const entry = {
                        timestamp: Date.now(),
                        type: chaosType,
                        is_cubic: !!isCubic,
                        x_params: xArr,
                        y_params: yArr,
                        max_lyapunov: coefficients.max_lyapunov ?? null,
                        min_lyapunov: coefficients.min_lyapunov ?? null,
                        fractal_dimension: coefficients.fractal_dimension ?? null
                    };
                    chaosHistory.unshift(entry);
                    if (chaosHistory.length > CHAOS_HISTORY_LIMIT) chaosHistory.pop();
                    activeHistoryIndex = 0;
                    saveChaosHistory();
                    renderChaosHistory();
                }
            } catch (e) {
                console.warn('History update failed', e);
            }
        }

        // Validate and normalize point data before plotting
        function validateAndNormalizePointData(pointData) {
            if (!pointData) {
                throw new Error('No point data provided');
            }
            
            // If pointData is already an array of numbers (RGBA data), return as-is
            if (Array.isArray(pointData) && typeof pointData[0] === 'number') {
                return pointData;
            }
            
            // If pointData has a points property, extract it
            if (pointData.points) {
                return pointData.points;
            }
            
            // If pointData has numerical properties, assume it's already point data
            return pointData;
        }

        // Check if auto-regeneration should happen for the given method
        function shouldAutoRegenerate(method, fractalType) {
            // Disable auto-regeneration for chaos maps to allow separate generation and plotting
            if (method === 'random_chaos') {
                return false;
            }
            
            // Enable for all other fractal types
            return true;
        }

        // Generate chaotic map without plotting
        async function generateChaoticMapOnly() {
            if (isLoading || !generator) return;

            setLoading(true);

            try {
                const chaosType = elements.chaosFinderType.value;
                const testPoints = parseInt(elements.chaosTestPoints.value);
                const discardPoints = parseInt(elements.chaosDiscardPoints.value);
                const useAlphabet = elements.chaosRandomizationType.value === 'discrete';
                const isCubic = chaosType === 'cubic';

                console.log('🎲 Searching for chaotic map:', {
                    chaosType,
                    testPoints,
                    discardPoints,
                    useAlphabet,
                    isCubic
                });

                // Check if we should use iterative mode for all chaotic maps
                // For finding chaotic maps, we only need enough points to verify chaos, not full plot points
                const searchPoints = testPoints; // Use test points for parameter discovery
                
                console.log(`🔄 Searching for chaotic map with ${searchPoints.toLocaleString()} test points`);

                try {
                    const result_data = generator.find_random_chaos_extended 
                        ? generator.find_random_chaos_extended(searchPoints, testPoints, discardPoints, useAlphabet, isCubic)
                        : generator.find_random_chaos(searchPoints, testPoints, isCubic);
                    
                    // Store the chaotic map data for later plotting
                    storeChaoticMap(
                        result_data.points || result_data,
                        result_data, // Store the full result for accessing parameters
                        chaosType,
                        testPoints,
                        discardPoints,
                        useAlphabet,
                        isCubic,
                        null // Don't store original plot points - plotting will use current UI value
                    );

                    // Display the chaotic map information if extended data is available
                    if (result_data.x_params && result_data.y_params) {
                        displayChaoticMap(result_data);
                    }

                    console.log('✅ Chaotic map stored for plotting');

                } catch (error) {
                    console.warn('⚠️ Extended chaos finder not available, using basic version:', error);
                    const pointData = generator.find_random_chaos(searchPoints, testPoints, isCubic);
                    
                    storeChaoticMap(
                        pointData,
                        null, // No extended data available from basic version
                        chaosType,
                        testPoints,
                        discardPoints,
                        useAlphabet,
                        isCubic,
                        null // Don't store original plot points - plotting will use current UI value
                    );

                    // For basic version, show limited information
                    // Basic version fallback: no overlay

                    console.log('✅ Chaotic map stored for plotting');
                }

            } catch (error) {
                console.error('❌ Chaotic map generation failed:', error);
                showNotification('Error finding chaotic map. Check console for details.', 'error');
                storedChaoticMap = null;
            } finally {
                setLoading(false);
                updateChaosMapButtonStates();
            }
        }

        // Plot stored chaotic map with current parameters
        async function plotStoredChaoticMap() {
            if (isLoading || !generator || !storedChaoticMap) return;

            setLoading(true);

            try {
                // Check if parameters have been edited and apply them automatically
                const editedParams = getEditedParameters();
                if (editedParams && editedParams.xParams && editedParams.xParams.length > 0 && 
                    editedParams.yParams && editedParams.yParams.length > 0 &&
                    editedParams.xParams.every(p => typeof p === 'number' && !isNaN(p)) &&
                    editedParams.yParams.every(p => typeof p === 'number' && !isNaN(p))) {
                    console.log('🔄 Applying edited parameters automatically...');
                    // Update stored map coefficients with edited parameters
                    if (!storedChaoticMap.coefficients) storedChaoticMap.coefficients = {};
                    storedChaoticMap.coefficients.x_params = editedParams.xParams.slice();
                    storedChaoticMap.coefficients.y_params = editedParams.yParams.slice();
                } else {
                    console.log('🔄 No valid edited parameters found, using stored parameters');
                }

                const canvasSize = parseInt(elements.canvasSize.value);
                const aspectRatio = elements.aspectRatio.value;
                const colorScheme = parseInt(elements.colorScheme.value);

                // Calculate canvas dimensions
                let canvasWidth = canvasSize;
                let canvasHeight = canvasSize;
                
                if (aspectRatio === 'portrait') {
                    canvasWidth = Math.round(canvasSize * 3 / 4);
                    canvasHeight = canvasSize;
                } else if (aspectRatio === 'landscape') {
                    canvasWidth = canvasSize;
                    canvasHeight = Math.round(canvasSize * 3 / 4);
                }
                elements.canvas.width = canvasWidth;
                elements.canvas.height = canvasHeight;
                initializeCanvas(elements.canvas, elements.backgroundColor.value);

                // Get current plot points from UI (not stored original value)
                const requestedPoints = parseInt(elements.chaosPlotPoints.value);
                const batchSize = parseInt(elements.chaosBatchSize.value) || DEFAULT_BATCH_SIZE;

                console.log('🎨 Plotting stored chaotic map with:', {
                    originalType: storedChaoticMap.type,
                    canvasSize: `${canvasWidth}x${canvasHeight}`,
                    colorScheme,
                    requestedPoints: requestedPoints,
                    hasParameters: !!(storedChaoticMap.coefficients && storedChaoticMap.coefficients.x_params)
                });
                
                let result;
                
                // Check if we have parameters for iterative generation
                const hasParameters = storedChaoticMap.coefficients && 
                                    (storedChaoticMap.coefficients.x_params &&
                                     storedChaoticMap.coefficients.y_params);
                
                if (hasParameters) {
                    // Always use iterative batch generation for any point count
                    console.log(`🔄 Using iterative batch generation with progress for ${requestedPoints.toLocaleString()} points`);
                    
                    // Call the iterative function that has proper progress bars
                    setLoading(false); // Reset loading state since iterative function handles it
                    await plotChaoticMapIterative(requestedPoints, canvasWidth, canvasHeight, colorScheme);
                    return;
                
                } else if (storedChaoticMap.pointData) {
                    // Fallback to existing point data for smaller sets or when parameters not available
                    const normalizedPointData = validateAndNormalizePointData(storedChaoticMap.pointData);
                    const totalPointCount = normalizedPointData.length / 2;
                    
                    if (totalPointCount > batchSize) {
                        console.log(`🔄 Using density grid for ${totalPointCount.toLocaleString()} existing points`);
                        
                        // Calculate bounds
                        const bounds = generator.calculate_point_bounds(normalizedPointData);
                        const [minX, maxX, minY, maxY] = bounds;
                        
                        // Convert points to density grid
                        const density = generator.points_to_density_grid_with_bounds(
                            normalizedPointData, canvasWidth, canvasHeight, minX, maxX, minY, maxY
                        );
                        
                        // Convert density grid to RGBA
                        result = generator.density_grid_to_rgba(density, canvasWidth, canvasHeight, colorScheme);
                    } else {
                        // Use standard approach for smaller point sets
                        result = generator.points_to_rgba(normalizedPointData, canvasWidth, canvasHeight, colorScheme);
                    }
                } else {
                    throw new Error('No chaotic map data available for plotting. Please generate a chaotic map first.');
                }

                if (!result || result.length === 0) {
                    throw new Error('Plotting returned empty result');
                }

                // Display result
                const ctx = elements.canvas.getContext('2d');
                const imageData = new ImageData(new Uint8ClampedArray(result), canvasWidth, canvasHeight);
                ctx.putImageData(imageData, 0, 0);

                const pointCount = storedChaoticMap.pointData ? storedChaoticMap.pointData.length / 2 : 0;
                
                currentFractal = {
                    type: 'chaotic_map',
                    method: 'random_chaos',
                    imageData: result,
                    width: canvasWidth,
                    height: canvasHeight
                };

            } catch (error) {
                console.error('❌ Chaotic map plotting failed:', error);
                showNotification('Error plotting chaotic map. Check console for details.', 'error');
            } finally {
                setLoading(false);
                updateChaosMapButtonStates();
            }
        }

        // Generate and plot chaotic map (original behavior)
        async function generateAndPlotChaoticMap() {
            // Abort in-progress plotting and supersede tokens to stop current loop
            abortRequested = true;
            activeGenerationToken++;
            // Small delay to allow current batch cycle to observe abort flag
            await new Promise(r => setTimeout(r, 20));
            await generateChaoticMapOnly();
            // Immediately plot the new one if available
            if (storedChaoticMap) {
                await plotStoredChaoticMap();
            }
        }

        // Fractal Generation with enhanced error handling and logging
        async function generateFractal() {
            if (isLoading) return;
            // Signal abort to any running iterative process
            abortRequested = true;
            activeGenerationToken++;
            
            // Enhanced pre-flight checks
            if (!generator) {
                const errorMsg = 'WebAssembly not loaded. Please check setup instructions or refresh the page.';
                showNotification(errorMsg, 'error');
                console.error('❌ Generation failed:', errorMsg);
                
                if (window.debugFractal) {
                    console.log('💡 Run window.debugFractal.checkModuleStatus() for detailed diagnostics');
                }
                return;
            }

            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            const iterations = parseInt(elements.iterations.value);
            const canvasSize = parseInt(elements.canvasSize.value);
            const aspectRatio = elements.aspectRatio.value;
            const colorScheme = parseInt(elements.colorScheme.value);

            // Parameter validation with detailed feedback
            const paramValidation = {
                iterations: iterations > 0 && iterations <= 10000000,
                canvasSize: canvasSize > 0 && canvasSize <= 8192,
                colorScheme: colorScheme >= 0 && colorScheme <= 23
            };
            
            const invalidParams = Object.entries(paramValidation)
                .filter(([param, valid]) => !valid)
                .map(([param]) => param);
                
            if (invalidParams.length > 0) {
                const errorMsg = `Invalid parameters: ${invalidParams.join(', ')}. Please check your input values.`;
                showNotification(errorMsg, 'error');
                console.error('❌ Parameter validation failed:', { 
                    method, fractalType, iterations, canvasSize, colorScheme 
                });
                return;
            }

            // Calculate canvas dimensions based on aspect ratio
            let canvasWidth = canvasSize;
            let canvasHeight = canvasSize;
            
            if (aspectRatio === 'portrait') {
                canvasWidth = Math.round(canvasSize * 3 / 4);
                canvasHeight = canvasSize;
            } else if (aspectRatio === 'landscape') {
                canvasWidth = canvasSize;
                canvasHeight = Math.round(canvasSize * 3 / 4);
            }

            // Update canvas size
            elements.canvas.width = canvasWidth;
            elements.canvas.height = canvasHeight;
            
            // Initialize canvas with proper background to prevent transparency
            initializeCanvas(elements.canvas, elements.backgroundColor.value);

            setLoading(true);
            
            // Enhanced logging for generation start
            console.log('🚀 Starting fractal generation:', {
                method,
                fractalType,
                iterations,
                canvasSize: `${canvasWidth}x${canvasHeight}`,
                colorScheme
            });

            // Start performance monitoring if debug helpers available
            let startMemory = 0;
            if (window.debugFractal && performance.memory) {
                startMemory = performance.memory.usedJSHeapSize;
            }

            try {
                const startTime = performance.now();
                let result;
                let actualPointsUsed = iterations; // Default for escape-time fractals
                
                // Get WASM classes from global scope
                const { Rule, FractalPresets } = window;
                
                if (method === 'escape_time') {
                    // Escape-time fractals (Mandelbrot, Julia, Burning Ship)
                    actualPointsUsed = `${canvasWidth}x${canvasHeight} pixels`;
                    
                    console.log(`🔢 Generating ${fractalType} fractal...`);
                    
                    if (fractalType === 'mandelbrot') {
                        const bounds = getMandelbrotBounds(Math.max(canvasWidth, canvasHeight));
                        console.log('📐 Mandelbrot bounds:', bounds);
                        
                        const iterCounts = generator.mandelbrot_set(
                            canvasWidth, canvasHeight, 
                            bounds.xMin, bounds.xMax, 
                            bounds.yMin, bounds.yMax, 
                            iterations
                        );
                        result = generator.iterations_to_rgba(iterCounts, canvasWidth, canvasHeight, iterations, colorScheme);
                        
                    } else if (fractalType === 'julia') {
                        const bounds = getJuliaBounds(Math.max(canvasWidth, canvasHeight));
                        const real = parseFloat(elements.juliaReal.value);
                        const imag = parseFloat(elements.juliaImag.value);
                        
                        console.log('🌀 Julia parameters:', { real, imag, bounds });
                        
                        const iterCounts = generator.julia_set(
                            canvasWidth, canvasHeight,
                            bounds.xMin, bounds.xMax,
                            bounds.yMin, bounds.yMax,
                            real, imag, iterations
                        );
                        result = generator.iterations_to_rgba(iterCounts, canvasWidth, canvasHeight, iterations, colorScheme);
                        
                    } else if (fractalType === 'burning_ship') {
                        const bounds = getBurningShipBounds(Math.max(canvasWidth, canvasHeight));
                        console.log('🚢 Burning Ship bounds:', bounds);
                        
                        const iterCounts = generator.burning_ship(
                            canvasWidth, canvasHeight,
                            bounds.xMin, bounds.xMax,
                            bounds.yMin, bounds.yMax,
                            iterations
                        );
                        result = generator.iterations_to_rgba(iterCounts, canvasWidth, canvasHeight, iterations, colorScheme);
                    }
                    
                } else if (method === 'chaos_game') {
                    // Chaos game fractals - scale iterations with resolution for consistent brightness
                    const baseResolution = 600 * 600; // Base resolution for scaling
                    const currentResolution = canvasWidth * canvasHeight;
                    const scalingFactor = Math.sqrt(currentResolution / baseResolution);
                    const scaledIterations = Math.round(iterations * scalingFactor);
                    actualPointsUsed = scaledIterations;
                    
                    const compressionRatio = parseFloat(elements.compressionRatio.value);
                    const rotationAngle = parseFloat(elements.rotationAngle.value);
                    const ruleLength = parseInt(elements.ruleLength.value);
                    let ruleOffset = parseInt(elements.ruleOffset.value);
                    const ruleSymmetry = elements.ruleSymmetry.value === 'true';
                    
                    // For techs pattern, use techs skew as offset
                    if (fractalType === 'techs') {
                        ruleOffset = parseInt(elements.techsSkew.value);
                    }
                    
                    console.log('🎯 Chaos game parameters:', {
                        fractalType,
                        scaledIterations,
                        compressionRatio,
                        rotationAngle,
                        ruleLength,
                        ruleOffset,
                        ruleSymmetry
                    });
                    
                    const transforms = [[compressionRatio, rotationAngle]];
                    const rule = new Rule(ruleLength, ruleOffset, ruleSymmetry);
                    
                    if (fractalType === 'sierpinski') {
                        const vertices = FractalPresets.sierpinski_triangle();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, scaledIterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                        
                    } else if (fractalType === 'sierpinski_carpet') {
                        const vertices = FractalPresets.sierpinski_carpet();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, scaledIterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                        
                    } else if (fractalType === 'vicsek') {
                        const vertices = FractalPresets.vicsek_square();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, scaledIterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                        
                    } else if (fractalType === 't_square') {
                        const vertices = FractalPresets.t_square();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, scaledIterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                        
                    } else if (fractalType === 'techs') {
                        const vertices = FractalPresets.techs_pattern();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, scaledIterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                        
                    } else if (fractalType === 'webs') {
                        const vertices = FractalPresets.web_pattern();
                        const points = generator.chaos_game(vertices, 0.0, 0.0, scaledIterations, transforms, rule);
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                    }
                    
                } else if (method === 'ifs') {
                    // IFS fractals using user-defined parameters - scale iterations with resolution for consistent brightness
                    const baseResolution = 600 * 600; // Base resolution for scaling
                    const currentResolution = canvasWidth * canvasHeight;
                    const scalingFactor = Math.sqrt(currentResolution / baseResolution);
                    const scaledIterations = Math.round(iterations * scalingFactor);
                    actualPointsUsed = scaledIterations;
                    
                    const startX = parseFloat(elements.ifsStartX.value);
                    const startY = parseFloat(elements.ifsStartY.value);
                    
                    console.log('🔄 IFS parameters:', {
                        fractalType,
                        startX,
                        startY,
                        scaledIterations
                    });
                    
                    try {
                        const { transforms, probabilities, parseMode } = getIFSParameters();
                        console.log('🔧 IFS configuration:', { transforms, probabilities, parseMode });
                        
                        const points = generator.ifs_fractal(startX, startY, scaledIterations, transforms, probabilities, parseMode);
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                    } catch (error) {
                        console.error('❌ IFS parameter error:', error);
                        showNotification(`IFS Error: ${error.message}`, 'error');
                        setLoading(false);
                        return;
                    }
                    
                } else if (method === 'random_chaos') {
                    // Random chaos finder - scale plot points with resolution for consistent brightness
                    const baseResolution = 600 * 600; // Base resolution for scaling
                    const currentResolution = canvasWidth * canvasHeight;
                    const scalingFactor = Math.sqrt(currentResolution / baseResolution);
                    
                    const chaosType = elements.chaosFinderType.value;
                    const basePlotPoints = parseInt(elements.chaosPlotPoints.value);
                    const scaledPlotPoints = Math.round(basePlotPoints * scalingFactor);
                    actualPointsUsed = scaledPlotPoints;
                    const testPoints = parseInt(elements.chaosTestPoints.value);
                    const discardPoints = parseInt(elements.chaosDiscardPoints.value);
                    const useAlphabet = elements.chaosRandomizationType.value === 'discrete';
                    const isCubic = chaosType === 'cubic';
                    
                    console.log('🎲 Random chaos parameters:', {
                        chaosType,
                        scaledPlotPoints,
                        testPoints,
                        discardPoints,
                        useAlphabet,
                        isCubic
                    });
                    
                    // Try to call extended WebAssembly function with new parameters, fallback if not available
                    try {
                        const result_data = generator.find_random_chaos_extended(scaledPlotPoints, testPoints, discardPoints, useAlphabet, isCubic);
                        
                        // Extract points and map equation if available
                        const points = result_data.points || result_data;
                        
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                    } catch (error) {
                        // Fallback to original function if extended one is not available
                        console.warn('⚠️ Extended chaos finder not available, using basic version:', error);
                        const points = generator.find_random_chaos(scaledPlotPoints, testPoints, isCubic);
                        
                        result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                    }
                }

                // Validate result
                if (!result || result.length === 0) {
                    throw new Error('WebAssembly function returned empty result');
                }
                
                if (result.length !== canvasWidth * canvasHeight * 4) {
                    console.warn(`⚠️ Result size mismatch: expected ${canvasWidth * canvasHeight * 4}, got ${result.length}`);
                }

                // Display result
                const ctx = elements.canvas.getContext('2d');
                const imageData = new ImageData(new Uint8ClampedArray(result), canvasWidth, canvasHeight);
                ctx.putImageData(imageData, 0, 0);

                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(2);
                
                // Enhanced performance and memory logging
                let memoryUsed = 0;
                if (window.debugFractal && performance.memory) {
                    const endMemory = performance.memory.usedJSHeapSize;
                    memoryUsed = (endMemory - startMemory) / 1024 / 1024; // MB
                }
                
                // Update status with detailed metrics
                const pointInfo = typeof actualPointsUsed === 'string' ? actualPointsUsed : `${actualPointsUsed.toLocaleString()} points`;
                const throughput = typeof actualPointsUsed === 'number' 
                    ? (actualPointsUsed / duration * 1000).toFixed(0) + ' points/sec'
                    : ((canvasWidth * canvasHeight) / duration * 1000).toFixed(0) + ' pixels/sec';
                    
                console.log('✅ Generation completed:', {
                    fractalType,
                    pointInfo,
                    duration: `${duration}ms`,
                    throughput,
                    memoryUsed: memoryUsed > 0 ? `${memoryUsed.toFixed(2)} MB` : 'N/A',
                    resultSize: result.length
                });
                    
                showNotification(`Fractal generated successfully! (${pointInfo} in ${duration}ms)`, 'success');
                
                // Auto-collapse sidebar on mobile after successful generation
                if (window.autoCollapseMobileAfterGeneration) {
                    setTimeout(() => {
                        window.autoCollapseMobileAfterGeneration();
                    }, 1000); // Small delay to let user see the success message
                }
                
                // Adapt background color based on fractal colors
                adaptBackgroundColor(result, canvasWidth, canvasHeight);
                
                currentFractal = {
                    type: fractalType,
                    method: method,
                    imageData: result,
                    width: canvasWidth,
                    height: canvasHeight,
                    generationTime: duration,
                    throughput: throughput
                };
                
                viewState.fractalType = fractalType;

            } catch (error) {
                console.error('❌ Fractal generation failed:', error);
                
                // Enhanced error reporting with context
                const errorContext = {
                    method,
                    fractalType,
                    iterations,
                    canvasSize: `${canvasWidth}x${canvasHeight}`,
                    errorMessage: error.message,
                    errorStack: error.stack,
                    timestamp: new Date().toISOString()
                };
                
                if (window.debugFractal) {
                    window.debugFractal.logError('GENERATION_FAILURE', JSON.stringify(errorContext));
                }
                
                // User-friendly error messages based on error type
                let userMessage = 'Error generating fractal. ';
                
                if (error.message.includes('memory')) {
                    userMessage += 'Try reducing the number of iterations or canvas size.';
                } else if (error.message.includes('parameter')) {
                    userMessage += 'Check your parameter values and try again.';
                } else if (error.message.includes('timeout')) {
                    userMessage += 'Generation took too long. Try simpler parameters.';
                } else {
                    userMessage += 'Check the browser console for details.';
                }
                
                showNotification(userMessage, 'error');
                
                console.log('💡 Troubleshooting suggestions:');
                console.log('  1. Try reducing iterations or canvas size');
                console.log('  2. Use window.debugFractal.validateParameters() to check inputs');
                console.log('  3. Run window.debugFractal.runBasicTests() to verify functionality');
                
            } finally {
                setLoading(false);
            }
        }

        // Background color adaptation based on fractal colors
        function adaptBackgroundColor(imageData, width, height) {
            // Sample colors from the fractal to get dominant hues
            const sampleSize = Math.min(1000, width * height / 10); // Sample 10% or max 1000 pixels
            const step = Math.floor(imageData.length / 4 / sampleSize);
            
            let totalR = 0, totalG = 0, totalB = 0;
            let sampleCount = 0;
            
            for (let i = 0; i < imageData.length; i += step * 4) {
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                const alpha = imageData[i + 3];
                
                // Only sample visible pixels
                if (alpha > 128) {
                    totalR += r;
                    totalG += g;
                    totalB += b;
                    sampleCount++;
                }
            }
            
            if (sampleCount > 0) {
                const avgR = Math.floor(totalR / sampleCount);
                const avgG = Math.floor(totalG / sampleCount);
                const avgB = Math.floor(totalB / sampleCount);
                
                // Create a darker, more muted version for background
                const bgR = Math.floor(avgR * 0.3);
                const bgG = Math.floor(avgG * 0.3);
                const bgB = Math.floor(avgB * 0.3);
                
                // Apply as gradient background
                document.body.style.background = `linear-gradient(135deg, rgb(${bgR}, ${bgG}, ${bgB}) 0%, rgb(${Math.floor(bgR * 0.7)}, ${Math.floor(bgG * 0.7)}, ${Math.floor(bgB * 0.7)}) 100%)`;
            }
        }

        // Get bounds for different fractal types based on zoom and pan
        function getMandelbrotBounds(size) {
            const baseWidth = 3.5;
            const baseHeight = 2.5;
            const width = baseWidth / viewState.zoom;
            const height = baseHeight / viewState.zoom;
            
            return {
                xMin: viewState.centerX - width / 2,
                xMax: viewState.centerX + width / 2,
                yMin: viewState.centerY - height / 2,
                yMax: viewState.centerY + height / 2
            };
        }

        function getJuliaBounds(size) {
            const baseWidth = 4.0;
            const baseHeight = 4.0;
            const width = baseWidth / viewState.zoom;
            const height = baseHeight / viewState.zoom;
            
            return {
                xMin: viewState.centerX - width / 2,
                xMax: viewState.centerX + width / 2,
                yMin: viewState.centerY - height / 2,
                yMax: viewState.centerY + height / 2
            };
        }

        function getBurningShipBounds(size) {
            const baseWidth = 3.5;
            const baseHeight = 3.0;
            const width = baseWidth / viewState.zoom;
            const height = baseHeight / viewState.zoom;
            
            return {
                xMin: viewState.centerX - width / 2,
                xMax: viewState.centerX + width / 2,
                yMin: viewState.centerY - height / 2,
                yMax: viewState.centerY + height / 2
            };
        }

        // Canvas Interaction
        function getCanvasCoordinates(clientX, clientY) {
            const rect = elements.canvas.getBoundingClientRect();
            const x = (clientX - rect.left) / rect.width;
            const y = (clientY - rect.top) / rect.height;
            return { x, y };
        }

        function canvasToFractalCoordinates(x, y) {
            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            
            // Only escape-time fractals support coordinate-based interaction
            if (method !== 'escape_time') {
                return { x: 0, y: 0 }; // Non-coordinate fractals
            }
            
            let bounds;
            
            if (fractalType === 'mandelbrot') {
                bounds = getMandelbrotBounds(elements.canvas.width);
            } else if (fractalType === 'julia') {
                bounds = getJuliaBounds(elements.canvas.width);
            } else if (fractalType === 'burning_ship') {
                bounds = getBurningShipBounds(elements.canvas.width);
            } else {
                return { x: 0, y: 0 };
            }
            
            const fractalX = bounds.xMin + x * (bounds.xMax - bounds.xMin);
            const fractalY = bounds.yMin + y * (bounds.yMax - bounds.yMin);
            
            return { x: fractalX, y: fractalY };
        }

        // Zoom functionality
        function zoomIn(centerX = null, centerY = null) {
            if (centerX !== null && centerY !== null) {
                const coords = canvasToFractalCoordinates(centerX, centerY);
                viewState.centerX = coords.x;
                viewState.centerY = coords.y;
            }
            viewState.zoom *= 2.0;
            updateStatus();
            generateFractal();
        }

        function zoomOut() {
            viewState.zoom /= 2.0;
            updateStatus();
            generateFractal();
        }

        function resetView() {
            viewState.centerX = 0;
            viewState.centerY = 0;
            viewState.zoom = 1.0;
            updateStatus();
            generateFractal();
        }

        // Download functionality with metadata embedding
        function downloadPNG() {
            if (!currentFractal) return;
            
            try {
                // Get PNG data from canvas
                const dataURL = elements.canvas.toDataURL('image/png');
                
                // Add metadata if we have chaotic map data
                let finalDataURL = dataURL;
                if (currentChaoticMapData && currentFractal.method === 'random_chaos') {
                    finalDataURL = addMetadataToPNG(dataURL, {
                        fractalType: currentFractal.type,
                        method: currentFractal.method,
                        xParams: currentChaoticMapData.x_params,
                        yParams: currentChaoticMapData.y_params,
                        isCubic: currentChaoticMapData.is_cubic,
                        maxLyapunov: currentChaoticMapData.max_lyapunov,
                        minLyapunov: currentChaoticMapData.min_lyapunov,
                        fractalDimension: currentChaoticMapData.fractal_dimension,
                        timestamp: new Date().toISOString()
                    });
                }
                
                const link = document.createElement('a');
                link.download = `fractal-${currentFractal.type}-${Date.now()}.png`;
                link.href = finalDataURL;
                link.click();
                
                showNotification('Fractal image downloaded with metadata!', 'success');
                
            } catch (error) {
                console.error('❌ Error downloading PNG:', error);
                // Fallback to basic download
                const link = document.createElement('a');
                link.download = `fractal-${currentFractal.type}-${Date.now()}.png`;
                link.href = elements.canvas.toDataURL('image/png');
                link.click();
                showNotification('Fractal image downloaded!', 'success');
            }
        }
        
        // Add metadata to PNG file
        function addMetadataToPNG(dataURL, metadata) {
            try {
                // Convert data URL to binary data
                const base64Data = dataURL.split(',')[1];
                const binaryData = atob(base64Data);
                const bytes = new Uint8Array(binaryData.length);
                for (let i = 0; i < binaryData.length; i++) {
                    bytes[i] = binaryData.charCodeAt(i);
                }
                
                // Create metadata text chunk
                const metadataText = JSON.stringify(metadata, null, 2);
                const textChunk = createPNGTextChunk('FractalParams', metadataText);
                
                // Insert text chunk after IHDR (should be at position 33 for standard PNG)
                const newBytes = insertPNGChunk(bytes, textChunk, 33);
                
                // Convert back to data URL
                let binaryString = '';
                for (let i = 0; i < newBytes.length; i++) {
                    binaryString += String.fromCharCode(newBytes[i]);
                }
                
                return 'data:image/png;base64,' + btoa(binaryString);
                
            } catch (error) {
                console.error('❌ Error adding metadata to PNG:', error);
                return dataURL; // Return original if metadata addition fails
            }
        }
        
        // Create PNG text chunk (tEXt format)
        function createPNGTextChunk(keyword, text) {
            const keywordBytes = new TextEncoder().encode(keyword);
            const textBytes = new TextEncoder().encode(text);
            const dataLength = keywordBytes.length + 1 + textBytes.length; // +1 for null separator
            
            // Create chunk data
            const chunkData = new Uint8Array(dataLength);
            chunkData.set(keywordBytes, 0);
            chunkData[keywordBytes.length] = 0; // null separator
            chunkData.set(textBytes, keywordBytes.length + 1);
            
            // Calculate CRC32
            const crc = calculateCRC32('tEXt', chunkData);
            
            // Create full chunk: length (4) + type (4) + data + crc (4)
            const chunk = new Uint8Array(4 + 4 + dataLength + 4);
            const view = new DataView(chunk.buffer);
            
            // Length (big-endian)
            view.setUint32(0, dataLength, false);
            
            // Type
            chunk.set(new TextEncoder().encode('tEXt'), 4);
            
            // Data
            chunk.set(chunkData, 8);
            
            // CRC (big-endian)
            view.setUint32(8 + dataLength, crc, false);
            
            return chunk;
        }
        
        // Insert chunk into PNG data
        function insertPNGChunk(pngBytes, chunk, position) {
            const newBytes = new Uint8Array(pngBytes.length + chunk.length);
            newBytes.set(pngBytes.slice(0, position), 0);
            newBytes.set(chunk, position);
            newBytes.set(pngBytes.slice(position), position + chunk.length);
            return newBytes;
        }
        
        // Simple CRC32 calculation for PNG chunks
        function calculateCRC32(type, data) {
            const typeBytes = new TextEncoder().encode(type);
            const combined = new Uint8Array(typeBytes.length + data.length);
            combined.set(typeBytes, 0);
            combined.set(data, typeBytes.length);
            
            let crc = 0xFFFFFFFF;
            const table = getCRC32Table();
            
            for (let i = 0; i < combined.length; i++) {
                crc = table[(crc ^ combined[i]) & 0xFF] ^ (crc >>> 8);
            }
            
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }
        
        // Get CRC32 lookup table
        function getCRC32Table() {
            if (getCRC32Table.table) return getCRC32Table.table;
            
            const table = new Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    if (c & 1) {
                        c = 0xEDB88320 ^ (c >>> 1);
                    } else {
                        c = c >>> 1;
                    }
                }
                table[i] = c;
            }
            
            getCRC32Table.table = table;
            return table;
        }

        // Dynamic control visibility
        function updateControlVisibility() {
            const method = elements.fractalMethod.value;
            
            // Hide all preset selectors
            elements.escapeTimePresets.style.display = 'none';
            elements.chaosGamePresets.style.display = 'none';
            elements.ifsPresets.style.display = 'none';
            elements.chaosFinderMethods.style.display = 'none';
            
            // Hide all method control sections
            elements.escapeTimeControls.style.display = 'none';
            elements.chaosGameControls.style.display = 'none';
            elements.ifsControls.style.display = 'none';
            elements.chaosFinderControls.style.display = 'none';
            elements.chaoticMapDisplay.style.display = 'none';
            
            // Show/hide appropriate buttons
            if (method === 'random_chaos') {
                // Show chaos map specific buttons, hide standard generate button
                elements.standardButtons.style.display = 'none';
                elements.chaosMapButtons.style.display = 'flex';
                updateChaosMapButtonStates();
            } else {
                // Show standard generate button, hide chaos map specific buttons
                elements.standardButtons.style.display = 'flex';
                elements.chaosMapButtons.style.display = 'none';
            }
            
            // Always show download section
            elements.downloadSection.style.display = 'flex';
            
            // Show relevant preset selector and controls
            if (method === 'escape_time') {
                elements.escapeTimePresets.style.display = 'block';
                elements.escapeTimeControls.style.display = 'block';
                if (elements.iterationsHelp) {
                    elements.iterationsHelp.textContent = 'Maximum iterations for escape-time calculation';
                }
                updateEscapeTimeControls();
                
            } else if (method === 'chaos_game') {
                elements.chaosGamePresets.style.display = 'block';
                elements.chaosGameControls.style.display = 'block';
                if (elements.iterationsHelp) {
                    elements.iterationsHelp.textContent = 'Number of points to generate with chaos game';
                }
                updateChaosGameDefaults();
                
            } else if (method === 'ifs') {
                elements.ifsPresets.style.display = 'block';
                elements.ifsControls.style.display = 'block';
                if (elements.iterationsHelp) {
                    elements.iterationsHelp.textContent = 'Number of points to generate with IFS';
                }
                
                // Initialize transformation inputs and load default preset
                createTransformationInputs();
                loadIFSPreset();
                
            } else if (method === 'random_chaos') {
                elements.chaosFinderMethods.style.display = 'block';
                elements.chaosFinderControls.style.display = 'block';
                elements.chaoticMapDisplay.style.display = 'block';
                if (elements.iterationsHelp) {
                    elements.iterationsHelp.textContent = 'Points generated after finding chaotic map';
                }
            }
            
            // Update iterations visibility after all other updates
            updateIterationsVisibility();
        }
        
        function updateEscapeTimeControls() {
            const fractalType = elements.escapeTimeType.value;
            
            // Hide all escape-time specific controls
            elements.juliaControls.classList.remove('active');
            
            // Show relevant controls
            if (fractalType === 'julia') {
                elements.juliaControls.classList.add('active');
            }
        }
        
        function getCurrentFractalType() {
            const method = elements.fractalMethod.value;
            
            if (method === 'escape_time') {
                return elements.escapeTimeType.value;
            } else if (method === 'chaos_game') {
                return elements.chaosGameType.value;
            } else if (method === 'ifs') {
                const ifsType = elements.ifsType.value;
                // Map IFS types to internal names
                if (ifsType === 'sierpinski_ifs') return 'sierpinski_ifs';
                return ifsType;
            } else if (method === 'random_chaos') {
                return 'random_chaos';
            }
            
            return 'mandelbrot'; // fallback
        }

        function updateChaosGameDefaults() {
            const chaosType = elements.chaosGameType.value;
            
            // Hide techs-specific controls
            elements.techsSkewGroup.style.display = 'none';
            
            // Set appropriate defaults for different chaos game patterns
            if (chaosType === 'sierpinski') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 0;
                elements.ruleOffset.value = 0;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 'sierpinski_carpet') {
                elements.compressionRatio.value = 0.67; // 2/3
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 0;
                elements.ruleOffset.value = 0;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 'vicsek') {
                elements.compressionRatio.value = 0.67; // 2/3
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 0;
                elements.ruleOffset.value = 0;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 't_square') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 1;
                elements.ruleOffset.value = 2;
                elements.ruleSymmetry.value = 'false';
                
            } else if (chaosType === 'techs') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0;
                elements.ruleLength.value = 1;
                elements.ruleOffset.value = 0; // Will be overridden by techsSkew
                elements.ruleSymmetry.value = 'false';
                elements.techsSkewGroup.style.display = 'block';
                
            } else if (chaosType === 'webs') {
                elements.compressionRatio.value = 0.5;
                elements.rotationAngle.value = 0.1;
                elements.ruleLength.value = 2;
                elements.ruleOffset.value = -1;
                elements.ruleSymmetry.value = 'true';
            }
        }

        // IFS parameter management functions
        function createTransformationInputs() {
            const count = parseInt(elements.ifsTransformCount.value);
            const container = elements.ifsTransformations;
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const transformDiv = document.createElement('div');
                transformDiv.className = 'ifs-transform';
                transformDiv.innerHTML = `
                    <h4>Transformation ${i + 1}</h4>
                    <div class="ifs-params">
                        </div>
                    </div><!-- end sidebar-scroll -->
                </div>
                        </div>
                        <div>
                            <label>b</label>
                            <input type="number" id="ifs_b_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>c</label>
                            <input type="number" id="ifs_c_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>d</label>
                            <input type="number" id="ifs_d_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>e</label>
                            <input type="number" id="ifs_e_${i}" value="0" step="0.01">
                        </div>
                        <div>
                            <label>f</label>
                            <input type="number" id="ifs_f_${i}" value="0" step="0.01">
                        </div>
                    </div>
                `;
                container.appendChild(transformDiv);
            }
            
            // Update probabilities placeholder
            const probPlaceholder = Array(count).fill(1.0 / count).map(p => p.toFixed(2)).join(', ');
            elements.ifsProbabilities.placeholder = `e.g., ${probPlaceholder}`;
        }

        function loadIFSPreset() {
            const presetName = elements.ifsType.value;
            
            // Preset data based on documentation
            const presets = {
                'dragon': {
                    transforms: [
                        [0.824074, 0.281428, -0.212346, 0.864198, -1.882290, -0.110607],
                        [0.088272, 0.520988, -0.463889, -0.377778, 0.785360, 8.095795]
                    ],
                    probabilities: [0.8, 0.2],
                    parseMode: 'borke'
                },
                'fern': {
                    transforms: [
                        [0.0, 0.0, 0.0, 0.16, 0.0, 0.0],
                        [0.2, -0.26, 0.23, 0.22, 0.0, 1.6],
                        [-0.15, 0.28, 0.26, 0.24, 0.0, 0.44],
                        [0.85, 0.04, -0.04, 0.85, 0.0, 1.6]
                    ],
                    probabilities: [0.01, 0.07, 0.07, 0.85],
                    parseMode: 'borke'
                },
                'leaf': {
                    transforms: [
                        [0.14, 0.01, 0.0, 0.51, -0.08, -1.31],
                        [0.43, 0.52, -0.45, 0.5, 1.49, -0.75],
                        [0.45, -0.49, 0.47, 0.47, -1.62, -0.74],
                        [0.49, 0.0, 0.0, 0.51, 0.02, 1.62]
                    ],
                    probabilities: [0.25, 0.25, 0.25, 0.25],
                    parseMode: 'borke'
                },
                'christmas': {
                    transforms: [
                        [0.0, -0.5, 0.5, 0.0, 0.5, 0.0],
                        [0.0, 0.5, -0.5, 0.0, 0.5, 0.5],
                        [0.5, 0.0, 0.0, 0.5, 0.25, 0.5]
                    ],
                    probabilities: [0.33, 0.33, 0.34],
                    parseMode: 'borke'
                },
                'spiral': {
                    transforms: [
                        [0.787879, -0.424242, 0.242424, 0.859848, 1.758647, 1.408065],
                        [-0.121212, 0.257576, 0.151515, 0.053030, -6.721654, 1.377236],
                        [0.181818, -0.136364, 0.090909, 0.181818, 6.086107, 1.568035]
                    ],
                    probabilities: [0.9, 0.05, 0.05],
                    parseMode: 'borke'
                },
                'mandelbrot_like': {
                    transforms: [
                        [0.2020, -0.8050, -0.3730, -0.6890, -0.3420, -0.6530],
                        [0.1380, 0.6650, 0.6600, -0.5020, -0.2220, -0.2770]
                    ],
                    probabilities: [0.5, 0.5],
                    parseMode: 'regular'
                },
                'sierpinski_ifs': {
                    transforms: [
                        [0.5, 0.0, 0.0, 0.0, 0.5, 0.0],
                        [0.5, 0.0, 0.5, 0.0, 0.5, 0.0],
                        [0.5, 0.0, 0.0, 0.0, 0.5, 0.5]
                    ],
                    probabilities: [0.33, 0.33, 0.34],
                    parseMode: 'regular'
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            // Set transform count and parsing mode
            elements.ifsTransformCount.value = preset.transforms.length;
            elements.ifsParseMode.value = preset.parseMode;
            
            // Create transform inputs with the correct count
            createTransformationInputs();
            
            // Fill in the transformation parameters
            preset.transforms.forEach((transform, i) => {
                document.getElementById(`ifs_a_${i}`).value = transform[0];
                document.getElementById(`ifs_b_${i}`).value = transform[1];
                document.getElementById(`ifs_c_${i}`).value = transform[2];
                document.getElementById(`ifs_d_${i}`).value = transform[3];
                document.getElementById(`ifs_e_${i}`).value = transform[4];
                document.getElementById(`ifs_f_${i}`).value = transform[5];
            });
            
            // Set probabilities
            elements.ifsProbabilities.value = preset.probabilities.join(', ');
        }

        function getIFSParameters() {
            const count = parseInt(elements.ifsTransformCount.value);
            const transforms = [];
            
            for (let i = 0; i < count; i++) {
                const transform = [
                    parseFloat(document.getElementById(`ifs_a_${i}`).value),
                    parseFloat(document.getElementById(`ifs_b_${i}`).value),
                    parseFloat(document.getElementById(`ifs_c_${i}`).value),
                    parseFloat(document.getElementById(`ifs_d_${i}`).value),
                    parseFloat(document.getElementById(`ifs_e_${i}`).value),
                    parseFloat(document.getElementById(`ifs_f_${i}`).value)
                ];
                transforms.push(transform);
            }
            
            // Parse probabilities
            const probStr = elements.ifsProbabilities.value.trim();
            const probabilities = probStr.split(',').map(p => parseFloat(p.trim()));
            
            // Validate probabilities
            if (probabilities.length !== count) {
                throw new Error(`Number of probabilities (${probabilities.length}) must match number of transformations (${count})`);
            }
            
            const probSum = probabilities.reduce((sum, p) => sum + p, 0);
            if (Math.abs(probSum - 1.0) > 0.1) {
                throw new Error(`Probabilities must sum to ~1.0 (current sum: ${probSum.toFixed(3)})`);
            }
            
            return {
                transforms,
                probabilities,
                parseMode: elements.ifsParseMode.value
            };
        }

        // Event Listeners
        elements.generateBtn.addEventListener('click', generateFractal);
        elements.downloadBtn.addEventListener('click', downloadPNG);
        
        // Chaos map specific button event listeners
        elements.generateAndPlotBtn.addEventListener('click', generateAndPlotChaoticMap);
        elements.generateMapBtn.addEventListener('click', generateChaoticMapOnly);
        elements.plotMapBtn.addEventListener('click', plotStoredChaoticMap);
        
    // Convergence mode toggle - show/hide advanced convergence thresholds
        function updateConvergenceMode() {
            const isConvergenceMode = elements.chaosConvergenceMode.checked;
            const plotPointsGroup = elements.chaosPlotPoints.closest('.control-group');
            
            if (isConvergenceMode) {
                // Hide plot points control when using auto-convergence
                plotPointsGroup.style.display = 'none';
        if (elements.convergenceAdvancedControls) elements.convergenceAdvancedControls.style.display = 'block';
            } else {
                // Show plot points control when not using auto-convergence
                plotPointsGroup.style.display = 'block';
        if (elements.convergenceAdvancedControls) elements.convergenceAdvancedControls.style.display = 'none';
            }
        }
        
        // Initialize convergence mode display
        updateConvergenceMode();
        
        // Add event listener for convergence mode checkbox
        elements.chaosConvergenceMode.addEventListener('change', updateConvergenceMode);
        
        // Enter key to generate fractal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !isLoading) {
                e.preventDefault();
                const method = elements.fractalMethod.value;
                if (method === 'random_chaos') {
                    generateAndPlotChaoticMap();
                } else {
                    generateFractal();
                }
            }
        });
        
        // Method and preset change handlers
        elements.fractalMethod.addEventListener('change', updateControlVisibility);
        elements.escapeTimeType.addEventListener('change', updateEscapeTimeControls);
        elements.chaosGameType.addEventListener('change', updateChaosGameDefaults);
        elements.ifsType.addEventListener('change', loadIFSPreset);
        elements.ifsTransformCount.addEventListener('change', createTransformationInputs);

        // Canvas click events - only for escape-time fractals
        elements.canvas.addEventListener('click', (e) => {
            if (isLoading) return;
            
            const method = elements.fractalMethod.value;
            if (method !== 'escape_time') return; // Only escape-time fractals support zooming
            
            const rect = elements.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            zoomIn(x, y);
        });

        elements.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (isLoading) return;
            
            const method = elements.fractalMethod.value;
            if (method !== 'escape_time') return; // Only escape-time fractals support zooming
            
            zoomOut();
        });

        // Canvas size change (disabled auto-regeneration for chaos maps)
        elements.canvasSize.addEventListener('change', function() {
            updateCanvasDisplaySize();
            
            const method = elements.fractalMethod.value;
            if (currentFractal && method !== 'random_chaos') {
                generateFractal();
            }
        });
        
        // Aspect ratio change (disabled auto-regeneration for chaos maps)
        elements.aspectRatio.addEventListener('change', function() {
            updateCanvasDisplaySize();
            
            const method = elements.fractalMethod.value;
            if (currentFractal && method !== 'random_chaos') {
                generateFractal();
            }
        });
        
        function updateCanvasDisplaySize() {
            const size = parseInt(elements.canvasSize.value);
            const aspectRatio = elements.aspectRatio.value;
            const isMobile = window.innerWidth <= 768;
            
            // Calculate canvas dimensions based on aspect ratio
            let canvasWidth = size;
            let canvasHeight = size;
            
            if (aspectRatio === 'portrait') {
                canvasWidth = Math.round(size * 3 / 4);
                canvasHeight = size;
            } else if (aspectRatio === 'landscape') {
                canvasWidth = size;
                canvasHeight = Math.round(size * 3 / 4);
            }
            
            // Update actual canvas size
            elements.canvas.width = canvasWidth;
            elements.canvas.height = canvasHeight;
            
            // Calculate maximum display size
            const sidebar = document.getElementById('sidebar');
            let maxDisplayWidth, maxDisplayHeight;
            
            if (isMobile) {
                // On mobile, use full viewport when sidebar is collapsed
                const sidebarCollapsed = sidebar.classList.contains('mobile-collapsed');
                maxDisplayWidth = window.innerWidth - 20; // Account for padding
                maxDisplayHeight = sidebarCollapsed 
                    ? window.innerHeight - 20 
                    : window.innerHeight - 200; // Leave space for collapsed controls
            } else {
                // Desktop calculation
                const sidebarWidth = sidebar.classList.contains('collapsed') ? 40 : 300;
                maxDisplayWidth = window.innerWidth - sidebarWidth - 40;
                maxDisplayHeight = window.innerHeight - 40;
            }
            
            // Scale display while maintaining aspect ratio
            const scaleX = maxDisplayWidth / canvasWidth;
            const scaleY = maxDisplayHeight / canvasHeight;
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond actual size
            
            const displayWidth = canvasWidth * scale;
            const displayHeight = canvasHeight * scale;
            
            elements.canvas.style.width = displayWidth + 'px';
            elements.canvas.style.height = displayHeight + 'px';
            
            // Center the canvas on mobile
            if (isMobile) {
                elements.container.style.display = 'flex';
                elements.container.style.justifyContent = 'center';
                elements.container.style.alignItems = 'center';
            }
        }
        
        // Update canvas display size on window resize
        window.addEventListener('resize', updateCanvasDisplaySize);

        // Real-time parameter updates for Julia set (disabled for chaos maps)
        elements.juliaReal.addEventListener('input', () => {
            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            if (method === 'escape_time' && fractalType === 'julia' && !isLoading) {
                clearTimeout(window.juliaTimeout);
                window.juliaTimeout = setTimeout(generateFractal, 500);
            }
        });

        elements.juliaImag.addEventListener('input', () => {
            const method = elements.fractalMethod.value;
            const fractalType = getCurrentFractalType();
            if (method === 'escape_time' && fractalType === 'julia' && !isLoading) {
                clearTimeout(window.juliaTimeout);
                window.juliaTimeout = setTimeout(generateFractal, 500);
            }
        });

        // Color scheme real-time update (disabled for chaos maps to prevent unwanted generation)
        elements.colorScheme.addEventListener('change', () => {
            const method = elements.fractalMethod.value;
            // For color scheme, fractalType is not relevant, pass undefined
            if (shouldAutoRegenerate(method, undefined)) {
                generateFractal();
            }
        });

        // Background color change - update main content background
        elements.backgroundColor.addEventListener('change', updateMainContentBackground);

        // Initialize application
        function initializeApp() {
            // Mobile detection
            const isMobile = window.innerWidth <= 768;
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            // Detect mobile and set default aspect ratio
            if (isMobile) {
                elements.aspectRatio.value = 'portrait';
                elements.canvasSize.value = '1024'; // Use smaller default for mobile
            } else {
                elements.aspectRatio.value = 'landscape';
            }
            
            // Set up sidebar toggle
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const appContainer = document.querySelector('.app-container');
            const SIDEBAR_MOBILE_STATE_KEY = 'fg.sidebar.mobileCollapsed.v1';
            const sidebarFab = document.getElementById('sidebarFab');
            
            // Enhanced mobile support
            function handleMobileLayout() {
                const isMobileView = window.innerWidth <= 768;
                
                if (isMobileView) {
                    // Mobile layout handling - restore persisted state or default to collapsed
                    let shouldCollapse = true; // Default to collapsed on mobile
                    try {
                        const persisted = localStorage.getItem(SIDEBAR_MOBILE_STATE_KEY);
                        if (persisted !== null) {
                            shouldCollapse = persisted === '1';
                        }
                    } catch (_) { /* ignore */ }
                    
                    // Apply the collapse state
                    sidebar.classList.toggle('mobile-collapsed', shouldCollapse);
                    sidebarToggle.textContent = shouldCollapse ? '↓' : '↑';
                    if (sidebarFab) sidebarFab.style.display = shouldCollapse ? 'inline-flex' : 'none';
                } else {
                    // Desktop layout
                    sidebar.classList.remove('mobile-collapsed');
                    if (sidebarFab) sidebarFab.style.display = sidebar.classList.contains('collapsed') ? 'inline-flex' : 'none';
                }
            }            // Auto-collapse sidebar on mobile after generation
            function autoCollapseMobileAfterGeneration() {
                const isMobileView = window.innerWidth <= 768;
                if (isMobileView) {
                    sidebar.classList.add('mobile-collapsed');
                    // Update toggle, persist state, and reveal FAB so users can restore controls
                    sidebarToggle.textContent = '↓';
                    try { localStorage.setItem(SIDEBAR_MOBILE_STATE_KEY, '1'); } catch (_) { /* ignore */ }
                    if (sidebarFab) sidebarFab.style.display = 'inline-flex';
                    // Recompute canvas size after layout change
                    setTimeout(updateCanvasDisplaySize, 0);
                }
            }
            
            // Store reference for use in generation function
            window.autoCollapseMobileAfterGeneration = autoCollapseMobileAfterGeneration;
            
        sidebarToggle.addEventListener('click', () => {
                const isMobileView = window.innerWidth <= 768;
                if (isMobileView) {
                    sidebar.classList.toggle('mobile-collapsed');
                    sidebarToggle.textContent = sidebar.classList.contains('mobile-collapsed') ? '↓' : '↑';
            try { localStorage.setItem(SIDEBAR_MOBILE_STATE_KEY, sidebar.classList.contains('mobile-collapsed') ? '1' : '0'); } catch (_) { /* ignore */ }
                    if (sidebarFab) sidebarFab.style.display = sidebar.classList.contains('mobile-collapsed') ? 'inline-flex' : 'none';
                } else {
                    sidebar.classList.toggle('collapsed');
                    appContainer.classList.toggle('sidebar-collapsed');
                    sidebarToggle.textContent = sidebar.classList.contains('collapsed') ? '→' : '←';
                    if (sidebarFab) sidebarFab.style.display = sidebar.classList.contains('collapsed') ? 'inline-flex' : 'none';
                }
                setTimeout(updateCanvasDisplaySize, 300);
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                handleMobileLayout();
                updateCanvasDisplaySize();
            });
            
            // Initial mobile layout setup (after sizing defaults)
            handleMobileLayout();
            // Ensure FAB visibility matches current state on first paint
            const isMobileView = window.innerWidth <= 768;
            if (isMobileView && sidebarFab) {
                sidebarFab.style.display = sidebar.classList.contains('mobile-collapsed') ? 'inline-flex' : 'none';
            }

            // Backdrop click closes the editor sheet
            const sheetBackdrop = document.getElementById('sheetBackdrop');
            if (sheetBackdrop) {
                sheetBackdrop.addEventListener('click', () => {
                    if (!elements.chipEditor) return;
                    elements.chipEditor.classList.remove('show');
                    setTimeout(() => { elements.chipEditor.style.display = 'none'; }, 180);
                    sheetBackdrop.style.display = 'none';
                    delete elements.chipEditor.dataset.editIndex;
                    elements.chipEditor.style.transform = '';
                });
            }

            // Sidebar FAB click expands the sidebar
            if (sidebarFab) {
                sidebarFab.addEventListener('click', () => {
                    const isMobileView = window.innerWidth <= 768;
                    if (isMobileView) {
                        sidebar.classList.remove('mobile-collapsed');
                        sidebarToggle.textContent = '↑';
                        try { localStorage.setItem(SIDEBAR_MOBILE_STATE_KEY, '0'); } catch (_) { /* ignore */ }
                        sidebarFab.style.display = 'none';
                    } else {
                        sidebar.classList.remove('collapsed');
                        appContainer.classList.remove('sidebar-collapsed');
                        sidebarToggle.textContent = '←';
                        sidebarFab.style.display = 'none';
                    }
                    updateCanvasDisplaySize();
                });
            }

            // Swipe-to-close for the bottom sheet (mobile)
            (function setupSheetGestures(){
                const editor = elements.chipEditor;
                if (!editor) return;
                let startY = 0;
                let currentY = 0;
                let dragging = false;
                const threshold = 80; // px to trigger close
                const backdrop = document.getElementById('sheetBackdrop');

                function onStart(e) {
                    const isMobileView = window.innerWidth <= 768;
                    if (!isMobileView || editor.style.display === 'none') return;
                    dragging = true;
                    editor.classList.add('dragging');
                    startY = (e.touches ? e.touches[0].clientY : e.clientY);
                    currentY = startY;
                }
                function onMove(e) {
                    if (!dragging) return;
                    currentY = (e.touches ? e.touches[0].clientY : e.clientY);
                    const delta = Math.max(0, currentY - startY);
                    editor.style.transform = `translateY(${delta}px)`;
                }
                function onEnd() {
                    if (!dragging) return;
                    const delta = Math.max(0, currentY - startY);
                    dragging = false;
                    editor.classList.remove('dragging');
                    if (delta > threshold) {
                        // close
                        editor.classList.remove('show');
                        setTimeout(() => { editor.style.display = 'none'; }, 180);
                        if (backdrop) backdrop.style.display = 'none';
                        delete editor.dataset.editIndex;
                        // reset transform for next open
                        editor.style.transform = '';
                    } else {
                        // snap back
                        editor.style.transform = '';
                    }
                }
                // Attach listeners to handle & content
                editor.addEventListener('touchstart', onStart, { passive: true });
                editor.addEventListener('touchmove', onMove, { passive: true });
                editor.addEventListener('touchend', onEnd);
                // Also support mouse drags on the handle
                const handle = editor.querySelector('.sheet-handle');
                if (handle) {
                    handle.addEventListener('mousedown', onStart);
                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onEnd);
                }
            })();

            // Adjust for on-screen keyboard using visualViewport (where available)
            if (window.visualViewport) {
                const editor = elements.chipEditor;
                const onViewportChange = () => {
                    if (!editor) return;
                    const isMobileView = window.innerWidth <= 768;
                    if (!isMobileView) return;
                    const vh = window.visualViewport.height;
                    // Limit height so content stays above keyboard
                    editor.style.maxHeight = Math.round(vh * 0.7) + 'px';
                };
                window.visualViewport.addEventListener('resize', onViewportChange);
                window.visualViewport.addEventListener('scroll', onViewportChange);
            }
            
            
            // Hide iterations parameter for Random Chaos Finder to avoid redundancy
            updateIterationsVisibility();
            
            // Add mobile-specific touch event handlers for canvas
            if (isTouchDevice) {
                setupMobileTouchHandlers();
            }
        }
        
        // Setup mobile touch handlers for better mobile interaction
        function setupMobileTouchHandlers() {
            let touchStartTime = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            
            elements.canvas.addEventListener('touchstart', (e) => {
                if (isLoading) return;
                
                touchStartTime = Date.now();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                
                // Prevent default to avoid scrolling
                e.preventDefault();
            });
            
            elements.canvas.addEventListener('touchend', (e) => {
                if (isLoading) return;
                
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                
                // Only handle tap (not swipe or long press)
                if (touchDuration < 200) {
                    const method = elements.fractalMethod.value;
                    if (method !== 'escape_time') return; // Only escape-time fractals support zooming
                    
                    const touch = e.changedTouches[0];
                    const rect = elements.canvas.getBoundingClientRect();
                    const x = (touch.clientX - rect.left) / rect.width;
                    const y = (touch.clientY - rect.top) / rect.height;
                    
                    zoomIn(x, y);
                }
                
                e.preventDefault();
            });
            
            // Handle double tap for zoom out
            let lastTap = 0;
            elements.canvas.addEventListener('touchend', (e) => {
                if (isLoading) return;
                
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 500 && tapLength > 0) {
                    // Double tap detected
                    const method = elements.fractalMethod.value;
                    if (method === 'escape_time') {
                        zoomOut();
                    }
                    e.preventDefault();
                }
                
                lastTap = currentTime;
            });
        }
        
        function updateIterationsVisibility() {
            const method = elements.fractalMethod.value;
            const iterationsGroup = elements.iterations.closest('.control-group');
            
            // Only hide iterations for Random Chaos Finder, show for all other methods
            if (method === 'random_chaos') {
                iterationsGroup.style.display = 'none';
            } else {
                iterationsGroup.style.display = 'block';
            }
        }
        
        // Chaotic Map Display and Management Functions
        let currentChaoticMapData = null;
        
        // Equation term structures for maintainability
        const CHAOTIC_MAP_EQUATION_TERMS = {
            cubic: [
                { idx: 0, fmt: v => `${v} ` },           // a
                { idx: 1, fmt: v => `+ ${v}x ` },        // b
                { idx: 2, fmt: v => `+ ${v}x² ` },       // c
                { idx: 3, fmt: v => `+ ${v}x³ ` },       // d
                { idx: 4, fmt: v => `+ ${v}x²y ` },      // e
                { idx: 5, fmt: v => `+ ${v}xy ` },       // f
                { idx: 6, fmt: v => `+ ${v}xy² ` },      // g
                { idx: 7, fmt: v => `+ ${v}y ` },        // h
                { idx: 8, fmt: v => `+ ${v}y² ` },       // i
                { idx: 9, fmt: v => `+ ${v}y³` },        // j
            ],
            quadratic: [
                { idx: 0, fmt: v => `${v} ` },           // a
                { idx: 1, fmt: v => `+ ${v}x ` },        // b
                { idx: 2, fmt: v => `+ ${v}x² ` },       // c
                { idx: 3, fmt: v => `+ ${v}xy ` },       // d
                { idx: 4, fmt: v => `+ ${v}y ` },        // e
                { idx: 5, fmt: v => `+ ${v}y²` },        // f
            ]
        };

        // Helper to defensively fill missing parameters with zeros
        function fillParams(params, length) {
            return Array.from({length}, (_, i) => params && params[i] !== undefined ? params[i] : 0);
        }

        function formatChaoticMapEquation(params, isCubic) {
            if (!params || params.length === 0) return 'No parameters available';

            const terms = isCubic ? CHAOTIC_MAP_EQUATION_TERMS.cubic : CHAOTIC_MAP_EQUATION_TERMS.quadratic;
            const safeParams = fillParams(params, terms.length);
            return terms.map((term) => term.fmt(safeParams[term.idx].toFixed(3))).join('').trim();
        }
        
    function createEditableEquation(params, isCubic, axis) {
            const terms = isCubic ? CHAOTIC_MAP_EQUATION_TERMS.cubic : CHAOTIC_MAP_EQUATION_TERMS.quadratic;
            const safeParams = fillParams(params, terms.length);
            
            return terms.map((term, i) => {
        const value = safeParams[term.idx].toFixed(3);
        return term.fmt(`<input type="number" step="0.001" value="${value}" data-param-axis="${axis}" data-param-index="${term.idx}" class="inline-param" inputmode="decimal">`);
            }).join('').trim();
        }
        
    function setupParameterChangeListeners() { /* sidebar editor removed */ }
        
        function displayChaoticMap(mapData) {
            currentChaoticMapData = mapData;
            // Refresh history chips so the active one (latest) is visible
            renderChaosHistory();
            // No canvas equation overlay anymore
        }

    function renderChaosHistory() {
        const host = document.getElementById('chaosHistory');
        if (!host) return;
        host.innerHTML = '';
        if (!chaosHistory.length) {
            const empty = document.createElement('span');
            empty.className = 'chip-meta';
            empty.textContent = 'No recent maps yet';
            host.appendChild(empty);
            return;
        }
        chaosHistory.forEach((entry, idx) => {
            const chip = document.createElement('div');
            chip.className = 'chaos-chip' + (idx === activeHistoryIndex ? ' active' : '');
            const typeText = entry.is_cubic ? 'cubic' : 'quad';
            const maxLE = (typeof entry.max_lyapunov === 'number') ? entry.max_lyapunov.toFixed(3) : '—';
            const fd = (typeof entry.fractal_dimension === 'number') ? entry.fractal_dimension.toFixed(2) : '—';
            chip.title = `Load ${typeText} map (${entry.x_params.length}/${entry.y_params.length} coeffs)`;
            chip.innerHTML = `
                <span class="chip-type">${typeText}</span>
                <span class="chip-meta">LE:${maxLE} · FD:${fd}</span>
                <span class="chip-actions">
                    <button class="chip-btn chip-edit" title="Edit">✎</button>
                    <button class="chip-btn chip-delete" title="Delete">×</button>
                </span>
            `;
            // Click on chip selects it (but ignore clicks on action buttons)
            chip.addEventListener('click', (e) => {
                const target = e.target;
                if (target && (target.classList.contains('chip-btn') || target.closest('.chip-actions'))) return;
                selectHistoryEntry(idx);
            });
            chip.querySelector('.chip-edit')?.addEventListener('click', (e) => {
                e.stopPropagation();
                openChipEditor(idx, chip);
            });
            chip.querySelector('.chip-delete')?.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteHistoryEntry(idx);
            });
            host.appendChild(chip);
        });
    }

    function selectHistoryEntry(idx, silent = false) {
        try {
            activeHistoryIndex = idx;
            const entry = chaosHistory[idx];
            if (!entry) return;
            // Update current map data snapshot
            currentChaoticMapData = {
                x_params: [...entry.x_params],
                y_params: [...entry.y_params],
                is_cubic: entry.is_cubic,
                max_lyapunov: entry.max_lyapunov ?? 0,
                min_lyapunov: entry.min_lyapunov ?? 0,
                fractal_dimension: entry.fractal_dimension ?? 0
            };
            // Prepare stored map so Plot works immediately
            storedChaoticMap = {
                type: 'history',
                testPoints: parseInt(elements.chaosTestPoints.value) || 100000,
                discardPoints: parseInt(elements.chaosDiscardPoints.value) || 10000,
                useAlphabet: elements.chaosRandomizationType.value === 'discrete',
                isCubic: !!entry.is_cubic,
                pointData: null,
                coefficients: {
                    x_params: [...entry.x_params],
                    y_params: [...entry.y_params],
                    max_lyapunov: entry.max_lyapunov ?? null,
                    min_lyapunov: entry.min_lyapunov ?? null,
                    fractal_dimension: entry.fractal_dimension ?? null
                },
                originalPlotPoints: 0
            };
            renderChaosHistory();
            updateChaosMapButtonStates();
            if (!silent) showNotification('Loaded coefficients from history', 'success');
        } catch (e) {
            console.error('Failed to load history entry', e);
            showNotification('Failed to load history entry', 'error');
        }
    }

    function openChipEditor(idx, anchorEl) {
        const entry = chaosHistory[idx];
        if (!entry || !elements.chipEditor) return;
        elements.chipEditor.dataset.editIndex = String(idx);
        elements.editorX.innerHTML = createEditableEquation(entry.x_params, entry.is_cubic, 'x');
        elements.editorY.innerHTML = createEditableEquation(entry.y_params, entry.is_cubic, 'y');
        const isMobile = window.innerWidth <= 768;
        const editor = elements.chipEditor;
        const backdrop = document.getElementById('sheetBackdrop');
        if (isMobile) {
            editor.style.display = 'block';
            requestAnimationFrame(() => editor.classList.add('show'));
            if (backdrop) backdrop.style.display = 'block';
        } else {
            // Position near the clicked chip inside the canvas container bounds
            try {
                const hostRect = elements.canvasDisplayWrapper.getBoundingClientRect();
                const anchorRect = (anchorEl || document.body).getBoundingClientRect();
                // Prefer to the right of the chip; clamp within canvas area
                const left = Math.min(
                    hostRect.right - 16 - 560,
                    Math.max(hostRect.left + 8, anchorRect.right + 8)
                );
                const top = Math.min(
                    hostRect.bottom - 16 - 160,
                    Math.max(hostRect.top + 8, anchorRect.top - 8)
                );
                editor.style.position = 'fixed';
                editor.style.left = `${left}px`;
                editor.style.top = `${top}px`;
            } catch (e) { /* fallback: default CSS position */ }
            editor.style.display = 'block';
            editor.classList.add('show');
        }
    }

    function deleteHistoryEntry(idx) {
        if (idx < 0 || idx >= chaosHistory.length) return;
        chaosHistory.splice(idx, 1);
        if (activeHistoryIndex >= chaosHistory.length) {
            activeHistoryIndex = chaosHistory.length - 1;
        }
        // If editor was open for this index, close it
        if (elements.chipEditor && elements.chipEditor.dataset.editIndex === String(idx)) {
            const backdrop = document.getElementById('sheetBackdrop');
            elements.chipEditor.classList.remove('show');
            setTimeout(() => { elements.chipEditor.style.display = 'none'; }, 180);
            if (backdrop) backdrop.style.display = 'none';
            delete elements.chipEditor.dataset.editIndex;
            // reset transform (in case of partial drag)
            elements.chipEditor.style.transform = '';
        }
        saveChaosHistory();
        renderChaosHistory();
    }
        
        function getEditedParameters(rootEl = elements.chipEditor, requireVisible = true) {
            const scope = rootEl || null;
            if (!scope) return null;
            // Optionally require the editor to be visible (prevents stale edits from forcing params)
            if (requireVisible) {
                const isVisible = !!(scope.classList.contains('show') && scope.style.display !== 'none');
                if (!isVisible) return null;
            }
            const xInputs = scope.querySelectorAll('input[data-param-axis="x"]');
            const yInputs = scope.querySelectorAll('input[data-param-axis="y"]');
            if (!xInputs.length || !yInputs.length) return null;
            const xParams = [];
            const yParams = [];
            xInputs.forEach(input => {
                const index = parseInt(input.dataset.paramIndex);
                xParams[index] = parseFloat(input.value);
            });
            yInputs.forEach(input => {
                const index = parseInt(input.dataset.paramIndex);
                yParams[index] = parseFloat(input.value);
            });
            return { xParams, yParams };
        }
        
        function getAspectRatio() {
            const aspectRatio = elements.aspectRatio.value;
            if (aspectRatio === 'portrait') {
                return 3/4; // width/height
            } else if (aspectRatio === 'landscape') {
                return 4/3; // width/height  
            } else {
                return 1; // square
            }
        }

        /* ================= Responsive Canvas Fitting ================= */
        function fitCanvasToViewport() {
            if (!elements.canvas || !elements.canvasDisplayWrapper) return;
            const canvas = elements.canvas;
            const wrapper = elements.canvasDisplayWrapper;

            // Reset any prior sizing so we calculate from intrinsic buffer size
            canvas.classList.remove('scaled');
            canvas.style.width = '';
            canvas.style.height = '';
            wrapper.style.width = '';
            wrapper.style.height = '';

            const internalW = canvas.width;
            const internalH = canvas.height;

            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;

            // Estimate sidebar width (if visible) by measuring .sidebar
            const sidebar = document.querySelector('.sidebar');
            const sidebarWidth = sidebar ? sidebar.getBoundingClientRect().width : 0;

            const availableW = Math.max(320, viewportW - sidebarWidth - 48); // leave some gap
            const availableH = Math.max(200, viewportH - 160); // leave room for controls/title

            const scaleW = availableW / internalW;
            const scaleH = availableH / internalH;
            const scale = Math.min(1, scaleW, scaleH);

            if (scale < 1) {
                const cssW = Math.floor(internalW * scale);
                const cssH = Math.floor(internalH * scale);
                canvas.style.width = cssW + 'px';
                canvas.style.height = cssH + 'px';
                canvas.classList.add('scaled');
                wrapper.style.width = cssW + 'px';
                wrapper.style.height = cssH + 'px';
            } else {
                // Use native size
                canvas.style.width = internalW + 'px';
                canvas.style.height = internalH + 'px';
                wrapper.style.width = internalW + 'px';
                wrapper.style.height = internalH + 'px';
            }
        }

        function observeCanvasResizing() {
            window.addEventListener('resize', () => requestAnimationFrame(fitCanvasToViewport));
        }

        // Wrap original function that sets canvas size so we can refit after changes
        const __originalSetCanvasAndAspectRatio = typeof setCanvasAndAspectRatio === 'function' ? setCanvasAndAspectRatio : null;
        if (__originalSetCanvasAndAspectRatio) {
            window.setCanvasAndAspectRatio = function() {
                __originalSetCanvasAndAspectRatio();
                requestAnimationFrame(fitCanvasToViewport);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize mobile interface first
            initializeMobileInterface();
            
            observeCanvasResizing();
            requestAnimationFrame(fitCanvasToViewport);
            // Overlay toggle wiring
            if (elements.toggleOverlayBtn) {
                elements.toggleOverlayBtn.addEventListener('click', () => {
                    const isShown = elements.equationOverlay.classList.toggle('show');
                    if (isShown) {
                        elements.toggleOverlayBtn.dataset.pinned = '1';
                    } else {
                        delete elements.toggleOverlayBtn.dataset.pinned;
                    }
                });
            }
        });
        /* ============================================================= */
    // Removed legacy compact parameter panel in favor of inline editable equations and history
        
        // Initialize canvas with proper background to prevent transparency issues
        function initializeCanvas(canvas, backgroundColor = '#000000') {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Apply background color to image data (for zero-value pixels)
        function applyBackgroundColor(imageData, backgroundColor, colorScheme) {
            const data = imageData.data;
            
            // Parse the hex color (may be overridden by min-density option)
            const hex = backgroundColor.replace('#', '');
            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);
            
            // Map numeric colorScheme to scheme name
            const schemeNames = ['Fire', 'Jet', 'Prism', 'Turbo', 'ColorWheel', 'Gnuplot', 'BMY', 'Plasma', 'Inferno', 'Viridis', 'Neon', 'Pastel', 'Magma', 'Cividis', 'Gray', 'Cubehelix', 'BlueOrange', 'Heat', 'Ice', 'WhiteFire', 'WhiteHeat', 'WhiteBlue', 'WhiteViridis', 'WhiteMagma'];
            const schemeName = schemeNames[colorScheme] || 'Fire';
            
            console.log(`🎨 Applying background color: ${backgroundColor} -> RGB(${r}, ${g}, ${b}) for ${schemeName} scheme`);
            
            // Define the background colors for each colormap scheme (t=0.0 values)
            const backgroundColors = {
                'Fire': [0, 0, 0],           // Pure black
                'Jet': [0, 0, 127],          // Dark blue  
                'Turbo': [34, 23, 27],       // Dark purple-brown
                'Prism': [255, 0, 0],        // Red (sector 0, fraction 0)
                'ColorWheel': [255, 127, 127], // cos(0)=1, sin(0)=0, cos(π/2)=0 -> 255,127,127
                'Gnuplot': [0, 0, 255],      // Blue
                'BMY': [0, 0, 255],          // Blue (t < 0.33 with scaled=0)
                'Plasma': [13, 8, 135],
                'Inferno': [0, 0, 4],
                'Viridis': [68, 1, 84],
                'Neon': [255, 0, 255],
                'Pastel': [248, 232, 244],
                'Magma': [0,0,4],
                'Cividis': [0,32,76],
                'Gray': [0,0,0],
                'Cubehelix': [0,0,0],
                'BlueOrange': [0,32,96],
                'Heat': [0,0,0],
                'Ice': [0,32,48]
                ,'WhiteFire': [255,255,255]
                ,'WhiteHeat': [255,255,255]
                ,'WhiteBlue': [255,255,255]
                ,'WhiteViridis': [255,255,255]
                ,'WhiteMagma': [255,255,255]
            };
            
            const targetColor = backgroundColors[schemeName] || [0, 0, 0]; // Default to black
            console.log(`🎯 Targeting background color for ${schemeName}: RGB(${targetColor})`);
            
            // If "no background" option is enabled, skip recoloring
            if (document.getElementById('noBackgroundColor')?.checked) {
                return imageData; // leave original colormap background
            }

            // If "use min-density color" is enabled, scan the image for the faintest non-background pixel color
            const useMinDensity = document.getElementById('bgUseMinDensityColor')?.checked;
            if (useMinDensity) {
                let found = false;
                let minBrightness = Number.POSITIVE_INFINITY;
                let minR = r, minG = g, minB = b;
                const isBg = (ri, gi, bi) => (ri === targetColor[0] && gi === targetColor[1] && bi === targetColor[2]);
                for (let i = 0; i < data.length; i += 4) {
                    const ri = data[i], gi = data[i + 1], bi = data[i + 2];
                    if (isBg(ri, gi, bi)) continue; // skip background pixels
                    // perceived luminance (ITU-R BT.601)
                    const luminance = 0.299 * ri + 0.587 * gi + 0.114 * bi;
                    if (luminance < minBrightness) {
                        minBrightness = luminance;
                        minR = ri; minG = gi; minB = bi;
                        found = true;
                    }
                }
                if (found) {
                    r = minR; g = minG; b = minB;
                    console.log(`🎯 Using min-density color as background: RGB(${r}, ${g}, ${b})`);
                } else {
                    console.log('ℹ️ No non-background pixels found; falling back to chosen background color.');
                }
            }

            let pixelsChanged = 0;
            
            // Apply background color to pixels matching the colormap's zero-density color
            for (let i = 0; i < data.length; i += 4) {
                // Check if pixel matches the background color for this colormap
                if (data[i] === targetColor[0] && 
                    data[i + 1] === targetColor[1] && 
                    data[i + 2] === targetColor[2]) {
                    data[i] = r;       // Red
                    data[i + 1] = g;   // Green  
                    data[i + 2] = b;   // Blue
                    // Alpha (data[i + 3]) stays the same
                    pixelsChanged++;
                }
            }
            
            console.log(`🎨 Background color applied to ${pixelsChanged} pixels`);
            
            return imageData;
        }
        
        // Iterative plotting function with progress bars
    async function plotChaoticMapIterative(requestedPoints, canvasWidth, canvasHeight, colorScheme) {
            console.log('🔄 plotChaoticMapIterative called with:', { requestedPoints, canvasWidth, canvasHeight, colorScheme });
            // Capture a new token for this run
            const runToken = ++activeGenerationToken;
            // Ensure any previous loop sees abortRequested
            abortRequested = false; // reset after increment to allow this run
            // Reset any previous accumulator to avoid cross-run contamination
            if (window.__chaosAccumulator) {
                console.log('♻️ Resetting previous ChaoticAccumulator instance');
                window.__chaosAccumulator = null;
            }
            console.log('🔄 Global state check:', { 
                storedChaoticMap: !!storedChaoticMap, 
                generator: !!generator,
                storedChaoticMapType: storedChaoticMap ? typeof storedChaoticMap : 'null'
            });
            
            if (!storedChaoticMap || !generator) {
                console.error('❌ Missing required objects for iterative plotting:', { storedChaoticMap: !!storedChaoticMap, generator: !!generator });
                return;
            }

            setLoading(true);
            
            // Hide batch progress indicator at start
            if (elements.batchProgress) {
                elements.batchProgress.classList.remove('visible');
            }
            
            try {
                // Get parameters - use edited ones if available, otherwise stored coefficients
                let xParams, yParams;
                const editedParams = getEditedParameters();
                
                // Validate edited parameters - use stored coefficients as fallback
                if (editedParams && editedParams.xParams && editedParams.xParams.length > 0 && 
                    editedParams.yParams && editedParams.yParams.length > 0 &&
                    editedParams.xParams.every(p => typeof p === 'number' && !isNaN(p)) &&
                    editedParams.yParams.every(p => typeof p === 'number' && !isNaN(p))) {
                    xParams = editedParams.xParams;
                    yParams = editedParams.yParams;
                    console.log('🔄 Using edited parameters for plotting');
                } else if (storedChaoticMap.coefficients && 
                          storedChaoticMap.coefficients.x_params && 
                          storedChaoticMap.coefficients.y_params) {
                    xParams = storedChaoticMap.coefficients.x_params;
                    yParams = storedChaoticMap.coefficients.y_params;
                    console.log('🔄 Using stored coefficients for plotting');
                } else {
                    throw new Error('No valid parameters available for plotting');
                }
                
                const batchSize = parseInt(elements.chaosBatchSize.value);
                const originalBatchSize = batchSize; // Keep track of original batch size for notification
                const isCubic = storedChaoticMap.isCubic;
                const softnessCtl = document.getElementById('densitySoftness');
                const softnessInput = document.getElementById('densitySoftnessInput');
                const getSoftness = () => parseFloat((softnessInput?.value || softnessCtl?.value || '10'));
                
                console.log(`🔄 Iterative plotting: ${requestedPoints.toLocaleString()} points in batches of ${batchSize.toLocaleString()}`);
                console.log(`🔄 Parameters: x[${xParams.slice(0,3).map(p => p.toFixed(3)).join(', ')}...], y[${yParams.slice(0,3).map(p => p.toFixed(3)).join(', ')}...]`);
                
                // For iterative mode, calculate bounds from a longer trajectory to capture full range
                const boundsCalculationPoints = Math.min(requestedPoints, batchSize * 3); // Use up to 3 batches worth for bounds
                console.log(`📏 Calculating bounds from ${boundsCalculationPoints} points for full trajectory coverage`);
                
                const boundsData = generator.generate_chaotic_map_points(xParams, yParams, boundsCalculationPoints, isCubic);
                const bounds = generator.calculate_point_bounds(boundsData);
                const [minX, maxX, minY, maxY] = bounds;
                
                console.log(`📏 Dynamic bounds: x[${minX.toFixed(3)}, ${maxX.toFixed(3)}], y[${minY.toFixed(3)}, ${maxY.toFixed(3)}]`);
                
                // Initialize accumulated density grid and state tracking
                let accumulatedDensity = new Array(canvasWidth * canvasHeight).fill(0);
                let processedPoints = 0;
                let batchCount = 0;
                let currentX = 0.05; // Initial state
                let currentY = 0.05;
                // Prevent duplicate finalization from overlapping timers
                let finished = false;
                
                // Convergence detection variables (early adaptive algorithm) using user thresholds
                const convergenceMode = document.getElementById('chaosConvergenceMode').checked;
                const totalPixels = canvasWidth * canvasHeight;
                const userRelPct = parseFloat(elements.relGrowthThreshold?.value || '0.05');
                const relativeGrowthThreshold = Math.max(0.0000005, userRelPct / 100.0); // convert percent to fraction
                const userAbsPixels = parseInt(elements.absGrowthPixels?.value || '50');
                const absoluteGrowthThreshold = userAbsPixels; // Only pixels threshold
                const minBatchesBeforeConvergence = 3; // Keep simple sensible defaults
                const requiredConsecutiveStagnant = 3;
                const minCoverageForConvergencePct = 0.0; // No minimum coverage requirement now
                let lastNonZero = 0;
                let stagnantCount = 0;
                let converged = false;
                let batchGrowths = []; // For logging
                console.log(`🎯 Convergence mode: ${convergenceMode ? 'ON' : 'OFF'}${convergenceMode ? ` (rel<th ${(relativeGrowthThreshold*100).toFixed(3)}%, abs<th ${absoluteGrowthThreshold} px, min batches ${minBatchesBeforeConvergence}, stagnant ${requiredConsecutiveStagnant})` : ''}`);
                
                // Reset abort state and show abort button
                // If a newer generation started, stop immediately
                if (runToken !== activeGenerationToken) {
                    console.log('⛔ Stale run detected before start; aborting.');
                    return;
                }
                abortRequested = false;
                const abortEl = document.getElementById('abortBatchesBtn');
                if (abortEl) {
                    abortEl.style.display = 'inline-block';
                    abortEl.disabled = false;
                    abortEl.textContent = 'Abort';
                }

                // Track total elapsed time for the whole plotting session
                const sessionStart = performance.now();
                // Process in batches with efficient state continuity
                const processBatch = () => {
                    if (finished) return; // guard against re-entry after finish
                const startTime = performance.now();
                    // Determine batch size; in convergence mode ignore requestedPoints cap
                    let currentBatchSize;
                    if (convergenceMode) {
                        currentBatchSize = batchSize; // steady batches until convergence
                    } else {
                        const remainingPoints = requestedPoints - processedPoints;
                        currentBatchSize = Math.min(batchSize, remainingPoints);
                    }

                    console.log(`🔄 processBatch called: processed=${processedPoints}, batchSize=${currentBatchSize}, mode=${convergenceMode ? 'convergence' : 'fixed'}`);
                    
                    // Cancel early if superseded by a new generation
                    if (runToken !== activeGenerationToken) {
                        console.log(`⛔ Stale batch loop (token ${runToken} != active ${activeGenerationToken}); stopping.`);
                        abortRequested = true;
                    }
                    if (abortRequested || (!convergenceMode && currentBatchSize <= 0) || (convergenceMode && converged)) {
                        if (finished) return;
                        finished = true;
                        const reason = converged ? 'convergence detected' : 'all points processed';
                        if (abortRequested) console.log('⛔ Abort requested; finalizing image');
                        console.log(`🎯 Stopping due to ${reason} - generating final image`);

                        let resultRgba;
                        let accRef = null;
                        if (window.__chaosAccumulator) {
                            accRef = window.__chaosAccumulator;
                            try {
                                const sCtl = document.getElementById('densitySoftness');
                                const sInp = document.getElementById('densitySoftnessInput');
                                const sVal = parseFloat((sInp?.value || sCtl?.value || '10'));
                                accRef.fill_rgba_log_soft(colorScheme, sVal);
                                resultRgba = accRef.rgba_view();
                            } catch (e) {
                                console.warn('⚠️ Accumulator finalization failed, falling back to JS density grid:', e);
                            }
                        }
                        if (!resultRgba) {
                            const sCtl = document.getElementById('densitySoftness');
                            const sInp = document.getElementById('densitySoftnessInput');
                            const sVal = parseFloat((sInp?.value || sCtl?.value || '10'));
                            resultRgba = generator.density_grid_to_rgba_log_soft(accumulatedDensity, canvasWidth, canvasHeight, colorScheme, sVal);
                        }

                        // Display result on canvas
                        elements.canvas.width = canvasWidth;
                        elements.canvas.height = canvasHeight;
                        initializeCanvas(elements.canvas, elements.backgroundColor.value);
                        const ctx = elements.canvas.getContext('2d');
                        const rgbaOut = resultRgba instanceof Uint8ClampedArray ? resultRgba : new Uint8ClampedArray(resultRgba);
                        const imageData = new ImageData(rgbaOut, canvasWidth, canvasHeight);
                        const finalImageData = applyBackgroundColor(imageData, elements.backgroundColor.value, colorScheme);
                        ctx.putImageData(finalImageData, 0, 0);

                        // Update current fractal data
                        currentFractal = {
                            type: 'chaotic_map',
                            method: 'random_chaos_iterative',
                            imageData: resultRgba,
                            width: canvasWidth,
                            height: canvasHeight,
                            parameters: { xParams, yParams, points: processedPoints },
                            colorScheme,
                            backgroundColor: elements.backgroundColor.value,
                            ...(accRef ? { accumulator: accRef } : { density: accumulatedDensity })
                        };
                        if (!accRef) {
                            lastAccumulatedDensity = accumulatedDensity.slice();
                        } else {
                            try { lastAccumulatedDensity = accRef.density(); } catch {}
                        }

                        hideBatchProgress();
                        if (abortEl) abortEl.style.display = 'none';
                        setLoading(false);
                        elements.downloadBtn.disabled = false;
                        updateChaosMapButtonStates();

                        const reasonText = abortRequested ? 'abort' : (converged ? 'convergence' : 'completion');
                        console.log(`🎯 Fractal plotted (${reasonText}) after ${batchCount} batches; points=${processedPoints.toLocaleString()}`);
                        return;
                    }
                    
                    batchCount++;
                    // In convergence mode, no meaningful percentage target; we'll show coverage instead after processing
                    
                    // Accumulator-based batch processing (in-WASM density)
                    setTimeout(async () => {
                        try {
                            if (!window.__chaosAccumulator) {
                                window.__chaosAccumulator = new ChaoticAccumulator(
                                    xParams.slice(), yParams.slice(), isCubic,
                                    canvasWidth, canvasHeight,
                                    minX, maxX, minY, maxY,
                                    currentX, currentY
                                );
                            }
                            const acc = window.__chaosAccumulator;
                            const stats = acc.step_batch_with_new(currentBatchSize); // [x,y,newPixels,totalNonZero]
                            currentX = stats[0];
                            currentY = stats[1];
                            const newPixels = stats[2];
                            const totalNonZero = stats[3];
                            processedPoints += currentBatchSize;

                            const coveragePct = (totalNonZero / totalPixels) * 100;
                            const delta = newPixels;
                            const relGrowth = lastNonZero > 0 ? delta / lastNonZero : 1.0;
                            if (convergenceMode && !converged) {
                                const stagnant = (delta <= absoluteGrowthThreshold) || (relGrowth <= relativeGrowthThreshold);
                                if (batchCount >= 2) { if (stagnant) stagnantCount++; else stagnantCount = 0; }
                                if (batchCount >= minBatchesBeforeConvergence && coveragePct >= minCoverageForConvergencePct && stagnantCount >= requiredConsecutiveStagnant) {
                                    converged = true;
                                    console.log(`🎯 ✅ CONVERGENCE DETECTED after ${batchCount} batches: coverage ${coveragePct.toFixed(3)}%, Δ=${delta}, relΔ=${(relGrowth*100).toFixed(3)}%`);
                                }
                            }
                            lastNonZero = totalNonZero;
                            const totalElapsed = performance.now() - sessionStart;
                            showBatchProgress(batchCount, coveragePct, delta.toLocaleString(), totalNonZero, totalElapsed);

                            const sCtl2 = document.getElementById('densitySoftness');
                            const sInp2 = document.getElementById('densitySoftnessInput');
                            const sVal2 = parseFloat((sInp2?.value || sCtl2?.value || '1'));
                            acc.fill_rgba_log_soft(colorScheme, sVal2);
                            const ctx = elements.canvas.getContext('2d');
                            const rgbaView = acc.rgba_view();
                            const imageData = new ImageData(rgbaView, canvasWidth, canvasHeight);
                            const bgImageData = applyBackgroundColor(imageData, elements.backgroundColor.value, colorScheme);
                            ctx.putImageData(bgImageData, 0, 0);

                            const shouldContinue = !abortRequested && runToken === activeGenerationToken && (convergenceMode ? !converged : processedPoints < requestedPoints);
                            if (shouldContinue) {
                                await new Promise(r => setTimeout(r, 5));
                                processBatch();
                            } else {
                                if (finished) return;
                                finished = true;
                                currentFractal = {
                                    type: 'chaotic_map',
                                    method: 'random_chaos_iterative',
                                    imageData: rgbaView,
                                    width: canvasWidth,
                                    height: canvasHeight,
                                    parameters: { xParams, yParams, points: processedPoints },
                                    colorScheme,
                                    backgroundColor: elements.backgroundColor.value,
                                    accumulator: acc
                                };
                                lastAccumulatedDensity = acc.density();
                                hideBatchProgress();
                                if (abortEl) abortEl.style.display = 'none';
                                setLoading(false);
                                elements.downloadBtn.disabled = false;
                                const reason = abortRequested ? 'abort' : (converged ? 'convergence' : 'completion');
                                console.log(`🎯 Fractal plotting finished via accumulator (${reason}) after ${batchCount} batches; points=${processedPoints.toLocaleString()}`);
                            }
                        } catch (error) {
                            console.error('❌ Accumulator batch error:', error);
                            hideBatchProgress();
                            setLoading(false);
                            showNotification('Error during accumulator batch processing.', 'error');
                        }
                    }, 5);
                };
                
                // Start batch processing
                processBatch();
                
            } catch (error) {
                console.error('❌ Error in iterative plotting:', error);
                hideBatchProgress();
                setLoading(false);
                showNotification('Error during plotting. Check console for details.', 'error');
            }
        }

        function regenerateWithCustomParametersIterative() {
            if (!currentChaoticMapData || !generator) return;
            
            const editedParams = getEditedParameters();
            
            // Validate parameters
            if (!editedParams || !editedParams.xParams || !editedParams.yParams || 
                editedParams.xParams.length === 0 || editedParams.yParams.length === 0 ||
                !editedParams.xParams.every(p => typeof p === 'number' && !isNaN(p)) ||
                !editedParams.yParams.every(p => typeof p === 'number' && !isNaN(p))) {
                showNotification('Invalid parameters. Please check that all parameter fields contain valid numbers.', 'error');
                return;
            }
            
            const { xParams, yParams } = editedParams;
            const totalPoints = parseInt(elements.chaosPlotPoints.value);
            const batchSize = parseInt(elements.chaosBatchSize.value);
            const iterativeMode = true; // Always use iterative mode
            const canvasWidth = parseInt(elements.canvasSize.value.split('x')[0]);
            const canvasHeight = Math.round(canvasWidth / getAspectRatio());
            const colorScheme = parseInt(elements.colorScheme.value);
            
            // Always use iterative mode regardless of batch size
            try {
                setLoading(true);
                
                console.log(`🔄 Iterative generation: ${totalPoints} points in batches of ${batchSize}`);
                
                // For iterative mode, we need to calculate bounds from a longer trajectory
                // to ensure we capture the full range of the extended orbit
                const boundsCalculationPoints = Math.min(totalPoints, batchSize * 3); // Use up to 3 batches worth for bounds
                console.log(`📏 Calculating bounds from ${boundsCalculationPoints} points for full trajectory coverage`);
                
                const boundsData = generator.generate_chaotic_map_points(xParams, yParams, boundsCalculationPoints, currentChaoticMapData.is_cubic);
                const bounds = generator.calculate_point_bounds(boundsData);
                const [minX, maxX, minY, maxY] = bounds;
                
                console.log(`� Dynamic bounds: x[${minX.toFixed(3)}, ${maxX.toFixed(3)}], y[${minY.toFixed(3)}, ${maxY.toFixed(3)}]`);
                
                // Initialize accumulated density grid and state tracking
                let accumulatedDensity = new Array(canvasWidth * canvasHeight).fill(0);
                let processedPoints = 0;
                let batchCount = 0;
                let currentX = 0.05; // Initial state
                let currentY = 0.05;
                
                // Dynamic bounds tracking - start with calculated bounds and expand as needed
                let dynamicMinX = minX;
                let dynamicMaxX = maxX;
                let dynamicMinY = minY;
                let dynamicMaxY = maxY;
                let boundsExpanded = false;
                
                // Process in batches with efficient state continuity
                const processBatch = () => {
                    const remainingPoints = totalPoints - processedPoints;
                    const currentBatchSize = Math.min(batchSize, remainingPoints);
                    
                    if (currentBatchSize <= 0) {
                        // All batches complete - generate final image
                        const result = generator.density_grid_to_rgba(accumulatedDensity, canvasWidth, canvasHeight, colorScheme);
                        
                        // Display result on canvas
                        elements.canvas.width = canvasWidth;
                        elements.canvas.height = canvasHeight;
                        const ctx = elements.canvas.getContext('2d');
                        const imageData = new ImageData(new Uint8ClampedArray(result), canvasWidth, canvasHeight);
                        ctx.putImageData(imageData, 0, 0);
                        
                        // Update current fractal data
                        currentFractal = {
                            type: 'chaotic_map',
                            method: 'random_chaos_iterative',
                            imageData: result,
                            width: canvasWidth,
                            height: canvasHeight
                        };
                        
                        // Overlay removed; keep internal state only
                        
                        // Update the stored data
                        currentChaoticMapData.x_params = xParams;
                        currentChaoticMapData.y_params = yParams;
                        
                        hideBatchProgress();
                        setLoading(false);
                        
                        let finalMessage = `High-resolution fractal generated! (${totalPoints.toLocaleString()} points in ${batchCount} batches)`;
                        if (boundsExpanded) {
                            finalMessage += ' Extended trajectory explored larger region.';
                        }
                        // Final processing complete
                        console.log(finalMessage);
                        return;
                    }
                    
                    batchCount++;
                    const progress = Math.round((processedPoints / totalPoints) * 100);
                    
                    showBatchProgress(batchCount);
                    
                    // Generate batch density grid with state continuity
                    setTimeout(() => {
                        try {
                            let batchDensity, currentBatchX, currentBatchY;
                            
                            // Try new efficient function first, fallback to old method
                            if (generator.generate_chaotic_map_batch_with_state) {
                                // Use the new efficient batch function with state continuity
                                const batchResult = generator.generate_chaotic_map_batch_with_state(
                                    xParams, yParams, currentBatchSize, currentChaoticMapData.is_cubic,
                                    canvasWidth, canvasHeight, dynamicMinX, dynamicMaxX, dynamicMinY, dynamicMaxY, currentX, currentY
                                );
                                
                                // Extract final state for next batch
                                currentBatchX = batchResult[0];
                                currentBatchY = batchResult[1];
                                
                                // Extract actual bounds encountered in this batch
                                const batchMinX = batchResult[2];
                                const batchMaxX = batchResult[3];
                                const batchMinY = batchResult[4];
                                const batchMaxY = batchResult[5];
                                
                                // Check if bounds need expansion
                                if (batchMinX < dynamicMinX || batchMaxX > dynamicMaxX || batchMinY < dynamicMinY || batchMaxY > dynamicMaxY) {
                                    console.log(`🔍 Trajectory exploring new regions - expanding bounds from batch ${batchCount}`);
                                    console.log(`📏 Old bounds: x[${dynamicMinX.toFixed(3)}, ${dynamicMaxX.toFixed(3)}], y[${dynamicMinY.toFixed(3)}, ${dynamicMaxY.toFixed(3)}]`);
                                    console.log(`📏 New bounds: x[${batchMinX.toFixed(3)}, ${batchMaxX.toFixed(3)}], y[${batchMinY.toFixed(3)}, ${batchMaxY.toFixed(3)}]`);
                                    
                                    // Expand bounds with some padding for future batches
                                    const paddingX = (batchMaxX - batchMinX) * 0.1;
                                    const paddingY = (batchMaxY - batchMinY) * 0.1;
                                    
                                    dynamicMinX = Math.min(dynamicMinX, batchMinX - paddingX);
                                    dynamicMaxX = Math.max(dynamicMaxX, batchMaxX + paddingX);
                                    dynamicMinY = Math.min(dynamicMinY, batchMinY - paddingY);
                                    dynamicMaxY = Math.max(dynamicMaxY, batchMaxY + paddingY);
                                    
                                    boundsExpanded = true;
                                    console.log(`📏 Expanded bounds: x[${dynamicMinX.toFixed(3)}, ${dynamicMaxX.toFixed(3)}], y[${dynamicMinY.toFixed(3)}, ${dynamicMaxY.toFixed(3)}]`);
                                }
                                
                                // Extract density grid (convert from f64 back to u32)
                                batchDensity = new Array(canvasWidth * canvasHeight);
                                for (let i = 0; i < batchDensity.length; i++) {
                                    batchDensity[i] = Math.round(batchResult[i + 6]);
                                }
                            } else {
                                // Fallback to old method
                                console.log(`⚠️ Using fallback batch method for batch ${batchCount}`);
                                batchDensity = generator.generate_chaotic_map_batch_to_density(
                                    xParams, yParams, currentBatchSize, currentChaoticMapData.is_cubic,
                                    canvasWidth, canvasHeight, minX, maxX, minY, maxY, processedPoints
                                );
                                
                                // For old method, we don't have state continuity, so use a simple approximation
                                currentBatchX = currentX;
                                currentBatchY = currentY;
                            }
                            
                            // Update state for next batch
                            currentX = currentBatchX;
                            currentY = currentBatchY;
                            
                            // Merge with accumulated density
                            if (batchDensity.length) {
                                accumulatedDensity = generator.merge_density_grids(accumulatedDensity, batchDensity);
                            } else {
                                // Manual merge for new method
                                for (let i = 0; i < accumulatedDensity.length; i++) {
                                    accumulatedDensity[i] += batchDensity[i];
                                }
                            }
                            
                            // Update canvas after each batch completion
                            const ctx = elements.canvas.getContext('2d');
                            const currentResult = generator.density_grid_to_rgba(accumulatedDensity, canvasWidth, canvasHeight, colorScheme);
                            const imageData = new ImageData(new Uint8ClampedArray(currentResult), canvasWidth, canvasHeight);
                            const finalImageData = applyBackgroundColor(imageData, elements.backgroundColor.value, colorScheme);
                            ctx.putImageData(finalImageData, 0, 0);
                            
                            processedPoints += currentBatchSize;
                            
                            // Show intermediate result if this is not the first batch
                            if (batchCount > 1 && batchCount % 2 === 0) {
                                const intermediateResult = generator.density_grid_to_rgba(accumulatedDensity, canvasWidth, canvasHeight, colorScheme);
                                const ctx = elements.canvas.getContext('2d');
                                const imageData = new ImageData(new Uint8ClampedArray(intermediateResult), canvasWidth, canvasHeight);
                                ctx.putImageData(imageData, 0, 0);
                            }
                            
                            // Process next batch
                            processBatch();
                            
                        } catch (error) {
                            console.error('❌ Error in batch processing:', error);
                            hideBatchProgress();
                            setLoading(false);
                            showNotification('Error during batch processing. Try reducing batch size.', 'error');
                        }
                    }, 10); // Small delay to allow UI updates
                };
                
                // Start batch processing
                processBatch();
                
            } catch (error) {
                console.error('❌ Error in iterative generation:', error);
                hideBatchProgress();
                setLoading(false);
                showNotification('Error in iterative generation.', 'error');
                // Don't fall back to non-iterative mode - iterative is the only mode
            }
        }

        // --- Dynamic recoloring without recomputation ---
        function recolorCurrentFractal() {
            if (!generator || !currentFractal) return;
            try {
                const newScheme = parseInt(elements.colorScheme.value);
                const bgColor = elements.backgroundColor.value;
                const sCtl = document.getElementById('densitySoftness');
                const sInp = document.getElementById('densitySoftnessInput');
                const sVal = parseFloat((sInp?.value || sCtl?.value || '1'));
                const w = currentFractal.width;
                const h = currentFractal.height;
                if (currentFractal.accumulator && typeof currentFractal.accumulator.fill_rgba_log_soft === 'function') {
                    // Zero-copy recolor using accumulator internal buffer
                    currentFractal.accumulator.fill_rgba_log_soft(newScheme, sVal);
                    const view = currentFractal.accumulator.rgba_view();
                    lastAccumulatedDensity = currentFractal.accumulator.density();
                    const ctx = elements.canvas.getContext('2d');
                    const imageData = new ImageData(view, w, h);
                    const finalImageData = applyBackgroundColor(imageData, bgColor, newScheme);
                    ctx.putImageData(finalImageData, 0, 0);
                    currentFractal.colorScheme = newScheme;
                    currentFractal.backgroundColor = bgColor;
                    currentFractal.imageData = view;
                    return;
                } else if (lastAccumulatedDensity) {
                    rgba = generator.density_grid_to_rgba_log_soft(lastAccumulatedDensity, w, h, newScheme, sVal);
                } else {
                    return; // nothing to recolor
                }
                const ctx = elements.canvas.getContext('2d');
                const rgbaOut = rgba instanceof Uint8ClampedArray ? rgba : new Uint8ClampedArray(rgba);
                const imageData = new ImageData(rgbaOut, w, h);
                const finalImageData = applyBackgroundColor(imageData, bgColor, newScheme);
                ctx.putImageData(finalImageData, 0, 0);
                currentFractal.colorScheme = newScheme;
                currentFractal.backgroundColor = bgColor;
                currentFractal.imageData = rgbaOut;
            } catch (e) {
                console.error('Dynamic recolor failed', e);
            }
        }

        // Listen for color scheme / background changes to live update
        elements.colorScheme.addEventListener('change', () => {
            recolorCurrentFractal();
        });
        elements.backgroundColor.addEventListener('input', () => {
            recolorCurrentFractal();
        });
        const minBg = document.getElementById('bgUseMinDensityColor');
        if (minBg) {
            minBg.addEventListener('change', () => {
                const noBg = document.getElementById('noBackgroundColor');
                elements.backgroundColor.disabled = (noBg?.checked ?? false) || minBg.checked;
                recolorCurrentFractal();
            });
        }
        const densityScaleSelect = document.getElementById('densityScaleMode');
        const densitySoftness = document.getElementById('densitySoftness');
        const densitySoftnessInput = document.getElementById('densitySoftnessInput');
        if (densitySoftness && densitySoftnessInput) {
            const syncSoftness = (val) => { densitySoftness.value = val; densitySoftnessInput.value = val; };
            densitySoftness.addEventListener('input', () => { densitySoftnessInput.value = densitySoftness.value; recolorCurrentFractal(); });
            densitySoftnessInput.addEventListener('change', () => { syncSoftness(densitySoftnessInput.value); recolorCurrentFractal(); });
        }
        const noBg = document.getElementById('noBackgroundColor');
        if (noBg) {
            noBg.addEventListener('change', () => {
                // Disable/enable color picker UI feedback
                const minBg = document.getElementById('bgUseMinDensityColor');
                elements.backgroundColor.disabled = noBg.checked || (minBg?.checked ?? false);
                recolorCurrentFractal();
            });
        }
        // Initialize disabled state on load
        (function initBgPickerDisabled(){
            const noBg = document.getElementById('noBackgroundColor');
            const minBg = document.getElementById('bgUseMinDensityColor');
            elements.backgroundColor.disabled = (noBg?.checked ?? false) || (minBg?.checked ?? false);
        })();
        
        function regenerateWithCustomParameters() {
            if (!currentChaoticMapData || !generator) return;
            
            const editedParams = getEditedParameters();
            
            // Validate parameters
            if (!editedParams || !editedParams.xParams || !editedParams.yParams || 
                editedParams.xParams.length === 0 || editedParams.yParams.length === 0 ||
                !editedParams.xParams.every(p => typeof p === 'number' && !isNaN(p)) ||
                !editedParams.yParams.every(p => typeof p === 'number' && !isNaN(p))) {
                showNotification('Invalid parameters. Please check that all parameter fields contain valid numbers.', 'error');
                return;
            }
            
            const { xParams, yParams } = editedParams;
            const plotPoints = parseInt(elements.chaosPlotPoints.value);
            const canvasWidth = parseInt(elements.canvasSize.value.split('x')[0]);
            const canvasHeight = Math.round(canvasWidth / getAspectRatio());
            const colorScheme = parseInt(elements.colorScheme.value);
            const batchSize = parseInt(elements.chaosBatchSize.value) || DEFAULT_BATCH_SIZE;
            
            try {
                setLoading(true);
                
                // Check if points exceed safe memory limit
                if (plotPoints > batchSize) {
                    setTimeout(() => {
                        setLoading(false);
                        showNotification(`Error: ${plotPoints.toLocaleString()} points exceeds memory limit. Reduce points to ${batchSize.toLocaleString()} or enable iterative mode.`, 'error');
                    }, 2000);
                    return;
                }
                
                const points = generator.generate_chaotic_map_points(xParams, yParams, plotPoints, currentChaoticMapData.is_cubic);
                const result = generator.points_to_rgba(points, canvasWidth, canvasHeight, colorScheme);
                
                // Display result on canvas
                elements.canvas.width = canvasWidth;
                elements.canvas.height = canvasHeight;
                const ctx = elements.canvas.getContext('2d');
                const imageData = new ImageData(new Uint8ClampedArray(result), canvasWidth, canvasHeight);
                ctx.putImageData(imageData, 0, 0);
                
                // Update current fractal data
                currentFractal = {
                    type: 'chaotic_map',
                    method: 'random_chaos',
                    imageData: result,
                    width: canvasWidth,
                    height: canvasHeight
                };
                
                // Overlay removed; keep internal state only
                
                // Update the stored data
                currentChaoticMapData.x_params = xParams;
                currentChaoticMapData.y_params = yParams;
                
                setLoading(false);
                showNotification('Fractal regenerated with custom parameters!', 'success');
                
            } catch (error) {
                console.error('❌ Error regenerating with custom parameters:', error);
                setLoading(false);
                showNotification('Error regenerating fractal. Check parameter values.', 'error');
            }
        }
        
        // Copy all parameters to clipboard
        async function copyParametersToClipboard() {
            try {
                const editedParams = getEditedParameters(elements.chipEditor);
                
                // Validate parameters
                if (!editedParams || !editedParams.xParams || !editedParams.yParams || 
                    editedParams.xParams.length === 0 || editedParams.yParams.length === 0 ||
                    !editedParams.xParams.every(p => typeof p === 'number' && !isNaN(p)) ||
                    !editedParams.yParams.every(p => typeof p === 'number' && !isNaN(p))) {
                    showNotification('Invalid parameters. Cannot copy invalid parameter values.', 'error');
                    return;
                }
                
                const { xParams, yParams } = editedParams;
                const parametersData = {
                    xParams: xParams,
                    yParams: yParams,
                    isCubic: currentChaoticMapData ? currentChaoticMapData.is_cubic : false
                };
                
                const parametersString = JSON.stringify(parametersData, null, 2);
                await navigator.clipboard.writeText(parametersString);
                showNotification('Parameters copied to clipboard!', 'success');
                
            } catch (error) {
                console.error('❌ Error copying parameters:', error);
                showNotification('Failed to copy parameters to clipboard', 'error');
            }
        }
        
        // Paste parameters from clipboard
        async function pasteParametersFromClipboard() {
            try {
                const clipboardText = await navigator.clipboard.readText();
                const parametersData = JSON.parse(clipboardText);
                
                // Validate the data structure
                if (!parametersData.xParams || !parametersData.yParams || 
                    !Array.isArray(parametersData.xParams) || !Array.isArray(parametersData.yParams)) {
                    throw new Error('Invalid parameters format');
                }
                
                // Update the inline parameter inputs
                const scope = elements.chipEditor || document;
                const xInputs = scope.querySelectorAll('.inline-param[data-param-axis="x"]');
                const yInputs = scope.querySelectorAll('.inline-param[data-param-axis="y"]');
                
                // Update X parameters
                parametersData.xParams.forEach((value, index) => {
                    const input = scope.querySelector(`.inline-param[data-param-axis="x"][data-param-index="${index}"]`);
                    if (input) {
                        input.value = value.toFixed(6);
                    }
                });
                
                // Update Y parameters
                parametersData.yParams.forEach((value, index) => {
                    const input = scope.querySelector(`.inline-param[data-param-axis="y"][data-param-index="${index}"]`);
                    if (input) {
                        input.value = value.toFixed(6);
                    }
                });
                
                // Show parameter buttons (removed Apply Changes button)
                elements.copyParametersBtn.style.display = 'inline-block';
                elements.pasteParametersBtn.style.display = 'inline-block';
                
                showNotification('Parameters pasted successfully!', 'success');
                
            } catch (error) {
                console.error('❌ Error pasting parameters:', error);
                showNotification('Failed to paste parameters. Please check clipboard format.', 'error');
            }
        }
        
        // Event listeners for chaotic map functionality
        function setupChaoticMapEventListeners() {
            if (elements.copyParametersBtn) elements.copyParametersBtn.addEventListener('click', copyParametersToClipboard);
            if (elements.pasteParametersBtn) elements.pasteParametersBtn.addEventListener('click', pasteParametersFromClipboard);
            const clearBtn = document.getElementById('clearChaosHistoryBtn');
            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    chaosHistory = [];
                    activeHistoryIndex = -1;
                    saveChaosHistory();
                    renderChaosHistory();
                });
            }
            if (elements.applyEditBtn) {
                elements.applyEditBtn.addEventListener('click', () => {
                    const idxStr = elements.chipEditor?.dataset.editIndex;
                    const idx = idxStr ? parseInt(idxStr) : -1;
                    if (idx < 0 || !chaosHistory[idx]) { elements.chipEditor?.classList.remove('show'); return; }
                    const edited = getEditedParameters();
                    if (!edited) { elements.chipEditor?.classList.remove('show'); return; }
                    const { xParams, yParams } = edited;
                    // Update entry
                    chaosHistory[idx].x_params = xParams.map(Number);
                    chaosHistory[idx].y_params = yParams.map(Number);
                    // Reflect into current map and stored map if this is active
                    if (activeHistoryIndex === idx) {
                        currentChaoticMapData.x_params = [...xParams];
                        currentChaoticMapData.y_params = [...yParams];
                        if (storedChaoticMap && storedChaoticMap.coefficients) {
                            storedChaoticMap.coefficients.x_params = [...xParams];
                            storedChaoticMap.coefficients.y_params = [...yParams];
                        }
                    }
                    saveChaosHistory();
                    renderChaosHistory();
                    if (elements.chipEditor) {
                        const backdrop = document.getElementById('sheetBackdrop');
                        elements.chipEditor.classList.remove('show');
                        setTimeout(() => { elements.chipEditor.style.display = 'none'; }, 180);
                        if (backdrop) backdrop.style.display = 'none';
                        delete elements.chipEditor.dataset.editIndex;
                        elements.chipEditor.style.transform = '';
                    }
                });
            }
            if (elements.cancelEditBtn) {
                elements.cancelEditBtn.addEventListener('click', () => {
                    if (!elements.chipEditor) return;
                    const backdrop = document.getElementById('sheetBackdrop');
                    elements.chipEditor.classList.remove('show');
                    setTimeout(() => { elements.chipEditor.style.display = 'none'; }, 180);
                    if (backdrop) backdrop.style.display = 'none';
                    delete elements.chipEditor.dataset.editIndex;
                    elements.chipEditor.style.transform = '';
                });
            }
            
            // Update batch count display when point count changes
            elements.chaosPlotPoints.addEventListener('input', updateBatchCountDisplay);
            
            // Update batch count display when batch size changes
            elements.chaosBatchSize.addEventListener('input', updateBatchCountDisplay);
        }
        
        function updateBatchCountDisplay() {
            const points = parseInt(elements.chaosPlotPoints.value) || 0;
            const batchSize = parseInt(elements.chaosBatchSize.value) || DEFAULT_BATCH_SIZE;
            const batches = Math.ceil(points / batchSize);
            
            // Update batch size help text to show calculated batches
            const helpText = elements.chaosBatchSize.closest('.control-group').querySelector('small');
            if (helpText) {
                helpText.textContent = `Points per batch (${points.toLocaleString()} ÷ ${batchSize.toLocaleString()} = ${batches} batches total)`;
            }
            
            console.log(`📊 Batch calculation: ${points} points ÷ ${batchSize} batch size = ${batches} batches`);
        }
        
    // Load persisted chaos history before initializing UI
    loadChaosHistory();
    initializeApp();
        initWasm();
        updateControlVisibility();
        updateStatus();
        updateCanvasDisplaySize();
        setupChaoticMapEventListeners();
    renderChaosHistory();
    // If history exists, select the most recent entry silently so Plot works
    if (chaosHistory.length > 0) {
        selectHistoryEntry(0, true);
    }
    updateBatchCountDisplay(); // Initialize batch count display
        updateMainContentBackground(); // Initialize main content background color
    </script>
</body>
</html>